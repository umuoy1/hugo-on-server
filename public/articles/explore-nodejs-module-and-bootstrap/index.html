<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="icon" href="https://s3.bmp.ovh/imgs/2022/02/5c58057419ddf5c7.png">

  <title>
    Node.js探索——启动与模块加载 - theumuoy&#39;s Garden
  </title>

  <meta name="description" content="版本：14.13.1
NOde.js的实际入口是src\node_main.cc，这里以Windows为例。
// node_main.cc int wmain(int argc, wchar_t* wargv[]) { // Windows Server 2012 (not R2) is supported until 10/10/2023, so we allow it  // to run in the experimental support tier.  // ...  argv[argc] = nullptr; return node::Start(argc, argv); } Windows下调用wmain类unix下调用main，调用Start启动Node.js
// src/node.cc int Start(int argc, char** argv) { // 初始化  InitializationResult result = InitializeOncePerProcess(argc, argv); // ... } 开始初始化，调用InitializeOncePerProcess。
在V8初始化之前，会执行一步初始化操作
// node.cc { result.exit_code = InitializeNodeWithArgs(&amp;(result." /><meta name="generator" content="Hugo 0.92.1" />

  <link rel="stylesheet" href="https://1aomn.com/css/main.css" />

  
  

  <meta property="og:title" content="Node.js探索——启动与模块加载" />
<meta property="og:description" content="版本：14.13.1
NOde.js的实际入口是src\node_main.cc，这里以Windows为例。
// node_main.cc int wmain(int argc, wchar_t* wargv[]) { // Windows Server 2012 (not R2) is supported until 10/10/2023, so we allow it  // to run in the experimental support tier.  // ...  argv[argc] = nullptr; return node::Start(argc, argv); } Windows下调用wmain类unix下调用main，调用Start启动Node.js
// src/node.cc int Start(int argc, char** argv) { // 初始化  InitializationResult result = InitializeOncePerProcess(argc, argv); // ... } 开始初始化，调用InitializeOncePerProcess。
在V8初始化之前，会执行一步初始化操作
// node.cc { result.exit_code = InitializeNodeWithArgs(&amp;(result." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://1aomn.com/articles/explore-nodejs-module-and-bootstrap/" /><meta property="og:image" content="https://1aomn.com/"/><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2020-10-08T20:17:56+08:00" />
<meta property="article:modified_time" content="2020-10-08T20:17:56+08:00" />



  <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://1aomn.com/"/>

<meta name="twitter:title" content="Node.js探索——启动与模块加载"/>
<meta name="twitter:description" content="版本：14.13.1
NOde.js的实际入口是src\node_main.cc，这里以Windows为例。
// node_main.cc int wmain(int argc, wchar_t* wargv[]) { // Windows Server 2012 (not R2) is supported until 10/10/2023, so we allow it  // to run in the experimental support tier.  // ...  argv[argc] = nullptr; return node::Start(argc, argv); } Windows下调用wmain类unix下调用main，调用Start启动Node.js
// src/node.cc int Start(int argc, char** argv) { // 初始化  InitializationResult result = InitializeOncePerProcess(argc, argv); // ... } 开始初始化，调用InitializeOncePerProcess。
在V8初始化之前，会执行一步初始化操作
// node.cc { result.exit_code = InitializeNodeWithArgs(&amp;(result."/>


  <meta itemprop="name" content="Node.js探索——启动与模块加载">
<meta itemprop="description" content="版本：14.13.1
NOde.js的实际入口是src\node_main.cc，这里以Windows为例。
// node_main.cc int wmain(int argc, wchar_t* wargv[]) { // Windows Server 2012 (not R2) is supported until 10/10/2023, so we allow it  // to run in the experimental support tier.  // ...  argv[argc] = nullptr; return node::Start(argc, argv); } Windows下调用wmain类unix下调用main，调用Start启动Node.js
// src/node.cc int Start(int argc, char** argv) { // 初始化  InitializationResult result = InitializeOncePerProcess(argc, argv); // ... } 开始初始化，调用InitializeOncePerProcess。
在V8初始化之前，会执行一步初始化操作
// node.cc { result.exit_code = InitializeNodeWithArgs(&amp;(result."><meta itemprop="datePublished" content="2020-10-08T20:17:56+08:00" />
<meta itemprop="dateModified" content="2020-10-08T20:17:56+08:00" />
<meta itemprop="wordCount" content="3473"><meta itemprop="image" content="https://1aomn.com/"/>
<meta itemprop="keywords" content="Node.js," />

  <meta itemprop="name" content="Node.js探索——启动与模块加载">
<meta itemprop="description" content="版本：14.13.1
NOde.js的实际入口是src\node_main.cc，这里以Windows为例。
// node_main.cc int wmain(int argc, wchar_t* wargv[]) { // Windows Server 2012 (not R2) is supported until 10/10/2023, so we allow it  // to run in the experimental support tier.  // ...  argv[argc] = nullptr; return node::Start(argc, argv); } Windows下调用wmain类unix下调用main，调用Start启动Node.js
// src/node.cc int Start(int argc, char** argv) { // 初始化  InitializationResult result = InitializeOncePerProcess(argc, argv); // ... } 开始初始化，调用InitializeOncePerProcess。
在V8初始化之前，会执行一步初始化操作
// node.cc { result.exit_code = InitializeNodeWithArgs(&amp;(result."><meta itemprop="datePublished" content="2020-10-08T20:17:56+08:00" />
<meta itemprop="dateModified" content="2020-10-08T20:17:56+08:00" />
<meta itemprop="wordCount" content="3473"><meta itemprop="image" content="https://1aomn.com/"/>
<meta itemprop="keywords" content="Node.js," />
</head><body class="flex relative h-full min-h-screen"><aside
  class="will-change-transform transform transition-transform -translate-x-full absolute top-0 left-0 md:relative md:translate-x-0 w-3/4 md:w-60 h-full min-h-screen p-3 bg-slate-50 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 flex flex-col gap-2.5 z-20 sidebar">
  <p class="font-bold mb-5 flex items-center gap-2">
    <button
      aria-label="Close sidebar"
      class="md:hidden menu-trigger-close p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-6 w-6" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <line x1="18" y1="6" x2="6" y2="18" />
  <line x1="6" y1="6" x2="18" y2="18" />
</svg></button>
    <a href="https://1aomn.com/" class="px-2">
      <span>theumuoy&#39;s Garden</span>
    </a>
    <button
      aria-label="Toggle dark mode"
      class="dark-mode-toggle p-2 rounded border dark:border-slate-700 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <circle cx="12" cy="12" r="4" />
  <path d="M3 12h1M12 3v1M20 12h1M12 20v1M5.6 5.6l.7 .7M18.4 5.6l-.7 .7M17.7 17.7l.7 .7M6.3 17.7l-.7 .7" />
</svg></button>
  </p>

  
  <ul class="list-none flex flex-col gap-1">
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/" >
        <span>Home</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles" >
        <span>Articles</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/portfolio" >
        <span>Portfolio</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/stack" >
        <span>Stack</span>
        
      </a>
    </li>
    
  </ul>

  <div class="flex-1"></div>

  

  <ul class="list-none flex flex-wrap justify-center gap-1 pt-2 border-t border-slate-200 dark:border-slate-600">
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm block text-slate-800 dark:text-slate-50  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="https://twitter.com/umuoy11" target="_blank" rel="noopener noreferrer">
        <span class="sr-only">Twitter</span>
        
        <span><svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
  stroke-linecap="round" stroke-linejoin="round">
  <path
    d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z" />
</svg></span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm block text-slate-800 dark:text-slate-50  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="https://github.com/umuoy1" target="_blank" rel="noopener noreferrer">
        <span class="sr-only">GitHub</span>
        
        <span><svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
  stroke-linecap="round" stroke-linejoin="round">
  <path
    d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" />
</svg></span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm block text-slate-800 dark:text-slate-50  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="burningdian@gmail.com" target="_blank" rel="noopener noreferrer">
        <span class="sr-only">Email</span>
        
        <span><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <rect x="3" y="5" width="18" height="14" rx="2" />
  <polyline points="3 7 12 13 21 7" />
</svg></span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm block text-slate-800 dark:text-slate-50  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/index.xml" target="_blank" rel="noopener noreferrer">
        <span class="sr-only">RSS</span>
        
        <span><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <circle cx="5" cy="19" r="1" />
  <path d="M4 4a16 16 0 0 1 16 16" />
  <path d="M4 11a9 9 0 0 1 9 9" />
</svg></span>
        
      </a>
    </li>
    
  </ul>
</aside>

<div
  class="fixed bg-slate-700 bg-opacity-5 transition duration-200 ease-in-out inset-0 z-10 pointer-events-auto md:hidden left-0 top-0 w-full h-full hidden menu-overlay">
</div>

<button
  aria-label="Toggle Sidebar"
  class="md:hidden absolute top-3 left-3 z-10 menu-trigger p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-100"><svg class="h-6 w-6" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <line x1="4" y1="6" x2="20" y2="6" />
  <line x1="4" y1="12" x2="20" y2="12" />
  <line x1="4" y1="18" x2="16" y2="18" />
</svg></button><div class="flex-1">



<div class="flex h-screen relative">

  <section
    class="will-change-transform transform transition-transform -translate-x-[200%] absolute top-0 left-0 lg:relative
  lg:translate-x-0 lg:min-w-[400px] lg:w-1/4 h-full bg-slate-50 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 lg:flex flex-col py-3 overflow-y-auto scroll-area">
    
    
    <a href="https://1aomn.com/articles/">
      <h2 class="font-bold mb-5 py-1 pl-12 pr-3 md:px-3">Articles</h2>
    </a>
    <div class="space-y-2.5">
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/js-regexp-test-exec-path/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">JavaScript 正则表达式 test 方法在 V8 中的执行路径</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          COMMIT ID:c97337ff5ece3c4838fedebddd762984d90ba6f4
regexp.prototype.test regexp-test.tq // 快速模式
-&gt; transitioning javascript builtin RegExpPrototypeTest -&gt; RegExpPrototypeExecBodyWithoutResultFast =&gt; regexp.tq -&gt; transitioning macro RegExpPrototypeExecBodyWithoutResultFast -&gt; RegExpPrototypeExecBodyWithoutResult -&gt; transitioning macro RegExpPrototypeExecBodyWithoutResult -&gt; RegExpExecInternal =&gt; builtins-regexp-gen.cc -&gt; TNode&lt;HeapObject&gt; RegExpBuiltinsAssembler::RegExpExecInternal -&gt; Runtime::kRegExpExec =&gt; runtime-regexp.cc -&gt; RUNTIME_FUNCTION(Runtime_RegExpExec) -&gt; RegExpExec -&gt; MaybeHandle&lt;Object&gt; RegExpExec -&gt; RegExp::Exec =&gt; regexp.cc -&gt; MaybeHandle&lt;Object&gt; RegExp::Exec -&gt; RegExpImpl::IrregexpExec // 慢速模式
-&gt; transitioning javascript builtin RegExpPrototypeTest -&gt; RegExpExec =&gt; regexp.tq -&gt; transitioning macro RegExpExec(implicit context: Context) -&gt; RegExpPrototypeExecSlow =&gt; regexp-exec.
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/distributed-locks/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Distributed Locks</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          分布式与单机最大的不同在于其是多进程而不是多线程。
多线程可以采取共享堆内存，通过内存来标记。
分布式的情况，需要将标记存在一个各进程都能看到的地方。
主要问题是：网络的延迟和不可靠。
分布式锁标记在&quot;公共内存&quot;中，如 Redis，Memcache。
 setnx(lockkey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向 2。 get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向 3。 计算 newExpireTime = 当前时间 + 过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值 currentExpireTime。 判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。 在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。  
        </div>
      </a>
      
      <a class="block px-3 py-4  bg-slate-900 dark:bg-slate-700 text-slate-50 "
        href="/articles/explore-nodejs-module-and-bootstrap/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Node.js探索——启动与模块加载</h3>
        <div
          class="text-sm  text-slate-400  line-clamp-2">
          版本：14.13.1
NOde.js的实际入口是src\node_main.cc，这里以Windows为例。
// node_main.cc int wmain(int argc, wchar_t* wargv[]) { // Windows Server 2012 (not R2) is supported until 10/10/2023, so we allow it  // to run in the experimental support tier.  // ...  argv[argc] = nullptr; return node::Start(argc, argv); } Windows下调用wmain类unix下调用main，调用Start启动Node.js
// src/node.cc int Start(int argc, char** argv) { // 初始化  InitializationResult result = InitializeOncePerProcess(argc, argv); // ... } 开始初始化，调用InitializeOncePerProcess。
在V8初始化之前，会执行一步初始化操作
// node.cc { result.exit_code = InitializeNodeWithArgs(&amp;(result.
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/%E5%8E%9F%E5%9E%8B%E9%93%BE/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Javascript 原型链</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          每个对象都有__proto__属性标识自己继承的原型。
函数被创建时，JS会为这个函数添加prototype属性，即该函数可以被当作构造函数使用，值是是一个对象，该对象有一个名为constructor的成员函数，值为该函数本身。
function Person(){ this.name = `Jack` } console.log(Person === Person.prototype.constructor) // true 通过new调用函数(当作构造函数)来构造对象时，会创建该函数的实例化对象，新对象的__proto__指向原函数的prototype属性来实现继承。
let obj = new Person() console.log(obj.__proto__ === Person.prototype) // true 函数也是一个对象，函数对象由Function构造，其__proto__指向Function.prototype。
Person.__proto__ === Function.prototype // true 通过new Object()和{}创建的对象，__proto__属性都指向Object.prototype，因为Object就是他们的构造函数，这与上面的行为是相一致的。
上面提到的，既然Person.prototype的值是一个对象，那么该对象也是有原型的，我们发现它指向Object.prototype，至此达到了该原型链的顶端。
Person.prototype.__proto__ === Object.prototype // true Object.prototype.__proto__ // null 但深究下去会发现，既然Object本身是构造函数，其__proto__指向Function.prototype，Function.prototype也是对象，继承了Object.prototype，这就产生了&quot;你中有我，我中有你&quot;的奇怪问题。
Object.__proto__ === Function.prototype // true Function.prototype.__proto__ === Object.prototype // true Function.__proto__ === Function.prototype // true 在ECMA规范15.3.4中：
 object (its [[Class]] is &quot;Function&quot;) that, when invoked, accepts any arguments and returns undefined.
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/streamerhelper/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">StreamerHelper</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Introduction StreamerHelper 是一个开源项目，可以实现虎牙、斗鱼、AfreecaTV等主流直播平台主播开播时自动录像，并适时上传。Github地址：https://github.com/ZhangMingZhao1/StreamerHelper。
StreamerHelper 使用Node.js开发，同时集成了直播录制和视频上传的功能，软件部署后，后台实时批量监测各个平台主播是否在线，并使用FFmpeg录制直播保存为视频文件，停播后投稿到b站。
Project Tree StreamerHelper ├─ src │ ├─ app.ts │ ├─ engine │ │ ├─ getStreamUrl.ts │ │ ├─ liveStreamStatus.ts │ │ ├─ message.ts │ │ ├─ RoomStatus.ts │ │ └─ website │ │ ├─ afreecatv.ts │ │ ├─ bilibili.ts │ │ ├─ cc.ts │ │ ├─ ... │ ├─ type │ │ ├─ StreamInfo.ts │ │ └─ VideoPart.ts │ ├─ uploader │ │ ├─ caller.ts │ │ ├─ example.
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/cookie-session-token/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Cookie，Session和token</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Cookie 定义 Cookie，中文名「小甜饼」，是一段用来标识用户身份和附加信息而存储在本地客户端上的字符串。
特点 Cookie有以下几个特点
 大小有限制，一般不超过5kb cookie 是没有结构的，但可以用格式如 &ldquo;a1=v1;a2=v2;a3=v3&quot;来存储结构化数据 跨域不共享，即浏览器为每个域名存储一个 cookie， 浏览器每次发送 http 请求，都会将请求域的 cookie 发送给服务端。这里的请求域仅指本次请求的域，比如在本站首页向 网易云音乐 发送 http 请求，则会向 网易云云音乐 发送本地存储的 cookie 。 服务端可以修改 cookie 并返回给浏览器。 浏览器可以在限制条件下修改 cookie 并返回给服务端。 cookie 在指定的域名及根域名下都生效。  使用 以下的例子在 Node.js 中演示。
首先是解析 cookie
req.cookie = {} const cookieStr = req.headers.cookie || &#39;&#39; cookieStr.split(&#39;;&#39;).forEach(element =&gt; { if(!element){ return } const arr = element.split(&#39;=&#39;) const key = arr[0] const val = arr[1] req.cookie[key]=val }); console.log(req.cookie) //为了方便测试，把cookie打印出来 在有登录验证的场景中，可以使用 cookie 验证用户是否登录
        </div>
      </a>
      
      <a class="block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/articles/build-a-blog/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">搭建Hugo博客，通过Netlify自动部署</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          本文章基于Windows10，Hugo_extended_0.66.0，博客发布的流程是本地上传到github，触发hook后，netlify自动发布
 一、下载并安装Hugo   Hugo下载地址
本教程选择了安装，该版本增加了对sass的支持 。
第1步：安装Hugo 下载解压，完成之后，把hugo.exe添加到全局变量Path。在控制台中验证安装成功。
  在Github上新建仓库hugo-on-netlify，并在D:\Blog目录下打开Gitbash，输入指令。
 $ git clone https://github.com/xxxxx/hugo-on-netlify
$ hugo new site hugo-on-netlify &ndash;force
 此时便会在hugo-on-netlify文件夹里生成网站需要的文件，文件结构如下。
 myblog ├── archetypes │ └── default.md ├── content ├── data ├── layouts ├── static ├── themes └── config.toml    第2步：安装主题Meme Hugo是没有默认主题的，这里选用主题Meme。
 $ git clone https://github.com/reuixiy/hugo-theme-meme.git themes/meme
 然后替换 config.toml 为 config.toml ，可以在其中进行个性化设置。
第3步：测试 创建测试页面
 $ hugo new posts/my-first-post.md
        </div>
      </a>
      </div>
    </section>

  <div class="overflow-y-auto h-screen w-full">
    <article class="px-6 py-20 w-full mx-auto prose lg:prose-lg h-fit dark:prose-invert prose-img:mx-auto">

      
      <h1 class="!mb-2">Node.js探索——启动与模块加载</h1>
      
      <p class="text-sm text-slate-500 !mb-8">October 8, 2020</p>
      

      

      <p>版本：14.13.1</p>
<p><code>NOde.js</code>的实际入口是<code>src\node_main.cc</code>，这里以<code>Windows</code>为例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_main.cc
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">wmain</span>(<span style="color:#8be9fd">int</span> argc, <span style="color:#8be9fd">wchar_t</span><span style="color:#ff79c6">*</span> wargv[]) {
  <span style="color:#6272a4">// Windows Server 2012 (not R2) is supported until 10/10/2023, so we allow it
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// to run in the experimental support tier.
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span>  argv[argc] <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">nullptr</span>;
  <span style="color:#ff79c6">return</span> node<span style="color:#ff79c6">::</span>Start(argc, argv);
}
</code></pre></div><p><code>Windows</code>下调用<code>wmain</code>类<code>unix</code>下调用<code>main</code>，调用<code>Start</code>启动<code>Node.js</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// src/node.cc
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">Start</span>(<span style="color:#8be9fd">int</span> argc, <span style="color:#8be9fd">char</span><span style="color:#ff79c6">**</span> argv) {
    <span style="color:#6272a4">// 初始化
</span><span style="color:#6272a4"></span>  InitializationResult result <span style="color:#ff79c6">=</span> InitializeOncePerProcess(argc, argv);
    <span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span>}
</code></pre></div><p>开始初始化，调用<code>InitializeOncePerProcess</code>。</p>
<p>在<code>V8</code>初始化之前，会执行一步初始化操作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node.cc
</span><span style="color:#6272a4"></span>{
    result.exit_code <span style="color:#ff79c6">=</span>
        InitializeNodeWithArgs(<span style="color:#ff79c6">&amp;</span>(result.args), <span style="color:#ff79c6">&amp;</span>(result.exec_args), <span style="color:#ff79c6">&amp;</span>errors);
    <span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span>    }
  }
</code></pre></div><p>初始化函数<code>InitializeNodeWithArgs</code>主要是调用<code>RegisterBuiltinModules</code>注册内建模块，处理一些<code>Node.js</code>配置及参数相关的内容。</p>
<p>调用<code>RegisterBuiltinModules</code>注册核心模块，其中定义了一个宏，调用<code>NODE_BUILTIN_MODULES(</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_binding.cc
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">RegisterBuiltinModules</span>() {
<span style="color:#ff79c6">#define V(modname) _register_##modname();
</span><span style="color:#ff79c6"></span>  NODE_BUILTIN_MODULES(V)
<span style="color:#ff79c6">#undef V
</span><span style="color:#ff79c6"></span>}
</code></pre></div><p>展开</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#ff79c6">#define NODE_BUILTIN_MODULES(V)                                                \
</span><span style="color:#ff79c6">  NODE_BUILTIN_STANDARD_MODULES(V)                                             \
</span><span style="color:#ff79c6">  NODE_BUILTIN_OPENSSL_MODULES(V)                                              \
</span><span style="color:#ff79c6">  NODE_BUILTIN_QUIC_MODULES(V)                                                 \
</span><span style="color:#ff79c6">  NODE_BUILTIN_ICU_MODULES(V)                                                  \
</span><span style="color:#ff79c6">  NODE_BUILTIN_PROFILER_MODULES(V)                                             \
</span><span style="color:#ff79c6">  NODE_BUILTIN_DTRACE_MODULES(V)
</span></code></pre></div><p>最终展开后如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_binding.cc
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">RegisterBuiltinModules</span>() {
	_register_async_wrap();
    _register_block_list();
    <span style="color:#6272a4">// _register_&lt;module name&gt;
</span><span style="color:#6272a4"></span>}
</code></pre></div><p>这些单独模块的注册函数定义在每个<code>C++</code>模块文件里，比如<code>async_wrap.cc</code>的结尾。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// async_wrap.cc
</span><span style="color:#6272a4"></span>NODE_MODULE_CONTEXT_AWARE_INTERNAL(async_wrap, node<span style="color:#ff79c6">::</span>AsyncWrap<span style="color:#ff79c6">::</span>Initialize)
</code></pre></div><p>其中<code>NODE_MODULE_CONTEXT_AWARE_INTERNAL</code>定义如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_binding.cc
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#define NODE_MODULE_CONTEXT_AWARE_INTERNAL(modname, regfunc)                   \
</span><span style="color:#ff79c6">  NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, nullptr, NM_F_INTERNAL)
</span></code></pre></div><p>展开</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_binding.cc
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#define NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags)           \
</span><span style="color:#ff79c6">  static node::node_module _module = {                                         \
</span><span style="color:#ff79c6">      NODE_MODULE_VERSION,                                                     \
</span><span style="color:#ff79c6">      flags,                                                                   \
</span><span style="color:#ff79c6">      nullptr,                                                                 \
</span><span style="color:#ff79c6">      __FILE__,                                                                \
</span><span style="color:#ff79c6">      nullptr,                                                                 \
</span><span style="color:#ff79c6">      (node::addon_context_register_func)(regfunc),                            \
</span><span style="color:#ff79c6">      NODE_STRINGIFY(modname),                                                 \
</span><span style="color:#ff79c6">      priv,                                                                    \
</span><span style="color:#ff79c6">      nullptr};                                                                \
</span><span style="color:#ff79c6">  void _register_##modname() { node_module_register(&amp;_module); }
</span></code></pre></div><p>每个<code>C++</code>模块的结尾，都注册了一个<code>_register_##modname</code>的函数，在注册<code>C++</code>模块时，经过一系列的宏展开，把所有模块的注册函数都执行一遍，其最终执行<code>node_module_register</code>。</p>
<p><code>C++</code>模块的结构以及<code>node_module_register</code>实现如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node.h
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">node_module</span> {
  <span style="color:#8be9fd">int</span> nm_version;
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> nm_flags;
  <span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> nm_dso_handle;
  <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> nm_filename;
  node<span style="color:#ff79c6">::</span>addon_register_func nm_register_func;
  node<span style="color:#ff79c6">::</span>addon_context_register_func nm_context_register_func;
  <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> nm_modname;
  <span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> nm_priv;
  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">node_module</span><span style="color:#ff79c6">*</span> nm_link;
};
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_binding.cc
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">extern</span> <span style="color:#f1fa8c">&#34;C&#34;</span> <span style="color:#8be9fd">void</span> node_module_register(<span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> m) {
  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">node_module</span><span style="color:#ff79c6">*</span> mp <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">reinterpret_cast</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">node_module</span><span style="color:#ff79c6">*&gt;</span>(m);

  <span style="color:#ff79c6">if</span> (mp<span style="color:#ff79c6">-&gt;</span>nm_flags <span style="color:#ff79c6">&amp;</span> NM_F_INTERNAL) {
    mp<span style="color:#ff79c6">-&gt;</span>nm_link <span style="color:#ff79c6">=</span> modlist_internal;
    modlist_internal <span style="color:#ff79c6">=</span> mp;
  } <span style="color:#ff79c6">else</span> <span style="color:#50fa7b">if</span> (<span style="color:#ff79c6">!</span>node_is_initialized) {
    <span style="color:#6272a4">// &#34;Linked&#34; modules are included as part of the node project.
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// Like builtins they are registered *before* node::Init runs.
</span><span style="color:#6272a4"></span>    mp<span style="color:#ff79c6">-&gt;</span>nm_flags <span style="color:#ff79c6">=</span> NM_F_LINKED;
    mp<span style="color:#ff79c6">-&gt;</span>nm_link <span style="color:#ff79c6">=</span> modlist_linked;
    modlist_linked <span style="color:#ff79c6">=</span> mp;
  } <span style="color:#ff79c6">else</span> {
    thread_local_modpending <span style="color:#ff79c6">=</span> mp;
  }
}
</code></pre></div><p>多个<code>C++</code>模块组成一个链表，并使用头插法连接。</p>
<p>通过这里可以知道，内建模块是注册到一个链表上，以供后续使用。</p>
<p>内建模块注册完毕以及一系列准备结束后，在函数的结尾，初始化<code>V8</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node.cc
</span><span style="color:#6272a4"></span>per_process<span style="color:#ff79c6">::</span>v8_platform.Initialize(
    per_process<span style="color:#ff79c6">::</span>cli_options<span style="color:#ff79c6">-&gt;</span>v8_thread_pool_size);
V8<span style="color:#ff79c6">::</span>Initialize();
performance<span style="color:#ff79c6">::</span>performance_v8_start <span style="color:#ff79c6">=</span> PERFORMANCE_NOW();
per_process<span style="color:#ff79c6">::</span>v8_initialized <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">true</span>;
</code></pre></div><p>初始化结束，根据<code>InitializeOncePerProcess(argc, argv)</code>返回的结果(包括初始化的<code>V8</code>)创建<code>NodeMainInstance</code>实例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node.cc
</span><span style="color:#6272a4"></span>Isolate<span style="color:#ff79c6">::</span>CreateParams params;
<span style="color:#ff79c6">const</span> std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>size_t<span style="color:#ff79c6">&gt;*</span> indexes <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">nullptr</span>;
<span style="color:#ff79c6">const</span> EnvSerializeInfo<span style="color:#ff79c6">*</span> env_info <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">nullptr</span>;
<span style="color:#8be9fd">bool</span> force_no_snapshot <span style="color:#ff79c6">=</span>
    per_process<span style="color:#ff79c6">::</span>cli_options<span style="color:#ff79c6">-&gt;</span>per_isolate<span style="color:#ff79c6">-&gt;</span>no_node_snapshot;
<span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>force_no_snapshot) {
  v8<span style="color:#ff79c6">::</span>StartupData<span style="color:#ff79c6">*</span> blob <span style="color:#ff79c6">=</span> NodeMainInstance<span style="color:#ff79c6">::</span>GetEmbeddedSnapshotBlob();
  <span style="color:#ff79c6">if</span> (blob <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nullptr</span>) {
    params.snapshot_blob <span style="color:#ff79c6">=</span> blob;
    indexes <span style="color:#ff79c6">=</span> NodeMainInstance<span style="color:#ff79c6">::</span>GetIsolateDataIndexes();
    env_info <span style="color:#ff79c6">=</span> NodeMainInstance<span style="color:#ff79c6">::</span>GetEnvSerializeInfo();
  }
}
uv_loop_configure(uv_default_loop(), UV_METRICS_IDLE_TIME);
NodeMainInstance <span style="color:#50fa7b">main_instance</span>(<span style="color:#ff79c6">&amp;</span>params,
                               uv_default_loop(),
                               per_process<span style="color:#ff79c6">::</span>v8_platform.Platform(),
                               result.args,
                               result.exec_args,
                               indexes);
result.exit_code <span style="color:#ff79c6">=</span> main_instance.Run(env_info);
</code></pre></div><p>初始化<code>NodeMainInstance</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#6272a4">// src/node_main_instance.cc
</span><span style="color:#6272a4"></span>NodeMainInstance<span style="color:#ff79c6">::</span>NodeMainInstance(
    Isolate<span style="color:#ff79c6">::</span>CreateParams<span style="color:#ff79c6">*</span> params,
    uv_loop_t<span style="color:#ff79c6">*</span> event_loop,
    MultiIsolatePlatform<span style="color:#ff79c6">*</span> platform,
    <span style="color:#ff79c6">const</span> std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>std<span style="color:#ff79c6">::</span>string<span style="color:#ff79c6">&gt;&amp;</span> args,
    <span style="color:#ff79c6">const</span> std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>std<span style="color:#ff79c6">::</span>string<span style="color:#ff79c6">&gt;&amp;</span> exec_args,
    <span style="color:#ff79c6">const</span> std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>size_t<span style="color:#ff79c6">&gt;*</span> per_isolate_data_indexes)
    <span style="color:#ff79c6">:</span> args_(args),
      exec_args_(exec_args),
      array_buffer_allocator_(ArrayBufferAllocator<span style="color:#ff79c6">::</span>Create()),
      isolate_(<span style="color:#ff79c6">nullptr</span>),
      platform_(platform),
      isolate_data_(<span style="color:#ff79c6">nullptr</span>),
      owns_isolate_(<span style="color:#8be9fd;font-style:italic">true</span>) {
  params<span style="color:#ff79c6">-&gt;</span>array_buffer_allocator <span style="color:#ff79c6">=</span> array_buffer_allocator_.get();
  deserialize_mode_ <span style="color:#ff79c6">=</span> per_isolate_data_indexes <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nullptr</span>;
  <span style="color:#ff79c6">if</span> (deserialize_mode_) {
    <span style="color:#ff79c6">const</span> std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>intptr_t<span style="color:#ff79c6">&gt;&amp;</span> external_references <span style="color:#ff79c6">=</span>
        CollectExternalReferences();
    params<span style="color:#ff79c6">-&gt;</span>external_references <span style="color:#ff79c6">=</span> external_references.data();
  }

  isolate_ <span style="color:#ff79c6">=</span> Isolate<span style="color:#ff79c6">::</span>Allocate();
  CHECK_NOT_NULL(isolate_);
  <span style="color:#6272a4">// Register the isolate on the platform before the isolate gets initialized,
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// so that the isolate can access the platform during initialization.
</span><span style="color:#6272a4"></span>  platform<span style="color:#ff79c6">-&gt;</span>RegisterIsolate(isolate_, event_loop);
  SetIsolateCreateParamsForNode(params);
  Isolate<span style="color:#ff79c6">::</span>Initialize(isolate_, <span style="color:#ff79c6">*</span>params);

  <span style="color:#6272a4">// If the indexes are not nullptr, we are not deserializing
</span><span style="color:#6272a4"></span>  CHECK_IMPLIES(deserialize_mode_, params<span style="color:#ff79c6">-&gt;</span>external_references <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nullptr</span>);
  isolate_data_ <span style="color:#ff79c6">=</span> std<span style="color:#ff79c6">::</span>make_unique<span style="color:#ff79c6">&lt;</span>IsolateData<span style="color:#ff79c6">&gt;</span>(isolate_,
                                                event_loop,
                                                platform,
                                                array_buffer_allocator_.get(),
                                                per_isolate_data_indexes);
  IsolateSettings s;
  SetIsolateMiscHandlers(isolate_, s);
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>deserialize_mode_) {
    <span style="color:#6272a4">// If in deserialize mode, delay until after the deserialization is
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// complete.
</span><span style="color:#6272a4"></span>    SetIsolateErrorHandlers(isolate_, s);
  }
}
</code></pre></div><p>可见<code>event loop</code>的创建是在这里完成的，之后它创建并初始化了一个<code>Isolate</code>实例，并在<code>Isolate</code>初始化之前，将<code>event loop</code>和<code>Isolate</code>注册到<code>platform</code>上。</p>
<p>完成一系列初始化之后，调用<code>NodeMainInstance::Run</code>。</p>
<p>这一步至关重要，<code>Environment</code>的创建，<code>V8</code>环境的启动以及<code>event loop</code>的执行都是在这里完成的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#6272a4">// node_main_instance.cc
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> NodeMainInstance<span style="color:#ff79c6">::</span>Run(<span style="color:#ff79c6">const</span> EnvSerializeInfo<span style="color:#ff79c6">*</span> env_info) {
  Locker <span style="color:#50fa7b">locker</span>(isolate_);
  Isolate<span style="color:#ff79c6">::</span>Scope isolate_scope(isolate_);
  HandleScope <span style="color:#50fa7b">handle_scope</span>(isolate_);

  <span style="color:#8be9fd">int</span> exit_code <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
  DeleteFnPtr<span style="color:#ff79c6">&lt;</span>Environment, FreeEnvironment<span style="color:#ff79c6">&gt;</span> env <span style="color:#ff79c6">=</span>
      CreateMainEnvironment(<span style="color:#ff79c6">&amp;</span>exit_code, env_info);

  CHECK_NOT_NULL(env);
  {
    Context<span style="color:#ff79c6">::</span>Scope context_scope(env<span style="color:#ff79c6">-&gt;</span>context());

    <span style="color:#ff79c6">if</span> (exit_code <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
      LoadEnvironment(env.get());

      env<span style="color:#ff79c6">-&gt;</span>set_trace_sync_io(env<span style="color:#ff79c6">-&gt;</span>options()<span style="color:#ff79c6">-&gt;</span>trace_sync_io);

      {
        SealHandleScope <span style="color:#50fa7b">seal</span>(isolate_);
        <span style="color:#8be9fd">bool</span> more;
        env<span style="color:#ff79c6">-&gt;</span>performance_state()<span style="color:#ff79c6">-&gt;</span>Mark(
            node<span style="color:#ff79c6">::</span>performance<span style="color:#ff79c6">::</span>NODE_PERFORMANCE_MILESTONE_LOOP_START);
        <span style="color:#ff79c6">do</span> {
          uv_run(env<span style="color:#ff79c6">-&gt;</span>event_loop(), UV_RUN_DEFAULT);

          per_process<span style="color:#ff79c6">::</span>v8_platform.DrainVMTasks(isolate_);

          more <span style="color:#ff79c6">=</span> uv_loop_alive(env<span style="color:#ff79c6">-&gt;</span>event_loop());
          <span style="color:#ff79c6">if</span> (more <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>env<span style="color:#ff79c6">-&gt;</span>is_stopping()) <span style="color:#ff79c6">continue</span>;

          <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>uv_loop_alive(env<span style="color:#ff79c6">-&gt;</span>event_loop())) {
            EmitBeforeExit(env.get());
          }

          <span style="color:#6272a4">// Emit `beforeExit` if the loop became alive either after emitting
</span><span style="color:#6272a4"></span>          <span style="color:#6272a4">// event, or after running some callbacks.
</span><span style="color:#6272a4"></span>          more <span style="color:#ff79c6">=</span> uv_loop_alive(env<span style="color:#ff79c6">-&gt;</span>event_loop());
        } <span style="color:#ff79c6">while</span> (more <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">true</span> <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>env<span style="color:#ff79c6">-&gt;</span>is_stopping());
        env<span style="color:#ff79c6">-&gt;</span>performance_state()<span style="color:#ff79c6">-&gt;</span>Mark(
            node<span style="color:#ff79c6">::</span>performance<span style="color:#ff79c6">::</span>NODE_PERFORMANCE_MILESTONE_LOOP_EXIT);
      }

      env<span style="color:#ff79c6">-&gt;</span>set_trace_sync_io(<span style="color:#8be9fd;font-style:italic">false</span>);
      <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>env<span style="color:#ff79c6">-&gt;</span>is_stopping()) env<span style="color:#ff79c6">-&gt;</span>VerifyNoStrongBaseObjects();
      exit_code <span style="color:#ff79c6">=</span> EmitExit(env.get());
    }

    ResetStdio();

<span style="color:#ff79c6">#if HAVE_INSPECTOR &amp;&amp; defined(__POSIX__) &amp;&amp; !defined(NODE_SHARED_MODE)
</span><span style="color:#ff79c6"></span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">sigaction</span> act;
  memset(<span style="color:#ff79c6">&amp;</span>act, <span style="color:#bd93f9">0</span>, <span style="color:#ff79c6">sizeof</span>(act));
  <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">unsigned</span> nr <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>; nr <span style="color:#ff79c6">&lt;</span> kMaxSignal; nr <span style="color:#ff79c6">+=</span> <span style="color:#bd93f9">1</span>) {
    <span style="color:#ff79c6">if</span> (nr <span style="color:#ff79c6">==</span> SIGKILL <span style="color:#ff79c6">||</span> nr <span style="color:#ff79c6">==</span> SIGSTOP <span style="color:#ff79c6">||</span> nr <span style="color:#ff79c6">==</span> SIGPROF)
      <span style="color:#ff79c6">continue</span>;
    act.sa_handler <span style="color:#ff79c6">=</span> (nr <span style="color:#ff79c6">==</span> SIGPIPE) <span style="color:#ff79c6">?</span> <span style="color:#8be9fd;font-style:italic">SIG_IGN</span> : SIG_DFL;
    CHECK_EQ(<span style="color:#bd93f9">0</span>, sigaction(nr, <span style="color:#ff79c6">&amp;</span>act, <span style="color:#ff79c6">nullptr</span>));
  }
<span style="color:#ff79c6">#endif
</span><span style="color:#ff79c6"></span>
<span style="color:#ff79c6">#if defined(LEAK_SANITIZER)
</span><span style="color:#ff79c6"></span>  __lsan_do_leak_check();
<span style="color:#ff79c6">#endif
</span><span style="color:#ff79c6"></span>  }

  <span style="color:#ff79c6">return</span> exit_code;
}
</code></pre></div><p>首先根据<code>isolate</code>创建<code>Locker</code>，用来完成<code>isolate</code>隔离以及线程独占。</p>
<p>之后调用<code>CreateMainEnvironment</code>创建环境，初始化<code>env</code>，<code>Environment</code>可以理解为<code>Node.js</code>的运行环境。</p>
<p>这里做了大量的初始化工作，展开分析一下。</p>
<p><code>CreateMainEnvironment</code>中创建了一个<code>Context</code>，然后初始化了一个<code>DeleteFnPtr</code>指针(本质上是<code>unique_ptr</code>)，之后通过这个指针初始化<code>Context</code>，之后调用<code>RunBootstrapping</code>，正式开始<code>Bootstrap</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> Environment<span style="color:#ff79c6">::</span>RunBootstrapping() {
  EscapableHandleScope <span style="color:#50fa7b">scope</span>(isolate_);

  CHECK(<span style="color:#ff79c6">!</span>has_run_bootstrapping_code());

  <span style="color:#ff79c6">if</span> (BootstrapInternalLoaders().IsEmpty()) {
    <span style="color:#ff79c6">return</span> MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span>();
  }

  Local<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> result;
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>BootstrapNode().ToLocal(<span style="color:#ff79c6">&amp;</span>result)) {
    <span style="color:#ff79c6">return</span> MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span>();
  }

  <span style="color:#6272a4">// Make sure that no request or handle is created during bootstrap -
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// if necessary those should be done in pre-execution.
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// Usually, doing so would trigger the checks present in the ReqWrap and
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// HandleWrap classes, so this is only a consistency check.
</span><span style="color:#6272a4"></span>  CHECK(req_wrap_queue()<span style="color:#ff79c6">-&gt;</span>IsEmpty());
  CHECK(handle_wrap_queue()<span style="color:#ff79c6">-&gt;</span>IsEmpty());

  set_has_run_bootstrapping_code(<span style="color:#8be9fd;font-style:italic">true</span>);

  <span style="color:#ff79c6">return</span> scope.Escape(result);
}
</code></pre></div><p>除了一些检查逻辑外，<code>RunBootstrapping</code>主要是调用了<code>BootstrapInternalLoaders</code>和<code>BootstrapNode</code>，其中第一步<code>BootstrapInternalLoaders</code>完成了内建模块和核心<code>JS</code>模块的加载。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node.cc
</span><span style="color:#6272a4"></span>MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> Environment<span style="color:#ff79c6">::</span>BootstrapInternalLoaders() {
  EscapableHandleScope <span style="color:#50fa7b">scope</span>(isolate_);

  <span style="color:#6272a4">// Create binding loaders
</span><span style="color:#6272a4"></span>  std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Local<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;&gt;</span> loaders_params <span style="color:#ff79c6">=</span> {
      process_string(),
      FIXED_ONE_BYTE_STRING(isolate_, <span style="color:#f1fa8c">&#34;getLinkedBinding&#34;</span>),
      FIXED_ONE_BYTE_STRING(isolate_, <span style="color:#f1fa8c">&#34;getInternalBinding&#34;</span>),
      primordials_string()};
  std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Local<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;&gt;</span> loaders_args <span style="color:#ff79c6">=</span> {
      process_object(),
      NewFunctionTemplate(binding<span style="color:#ff79c6">::</span>GetLinkedBinding)
          <span style="color:#ff79c6">-&gt;</span>GetFunction(context())
          .ToLocalChecked(),
      NewFunctionTemplate(binding<span style="color:#ff79c6">::</span>GetInternalBinding)
          <span style="color:#ff79c6">-&gt;</span>GetFunction(context())
          .ToLocalChecked(),
      primordials()};

  <span style="color:#6272a4">// Bootstrap internal loaders
</span><span style="color:#6272a4"></span>  Local<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> loader_exports;
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>ExecuteBootstrapper(
           <span style="color:#ff79c6">this</span>, <span style="color:#f1fa8c">&#34;internal/bootstrap/loaders&#34;</span>, <span style="color:#ff79c6">&amp;</span>loaders_params, <span style="color:#ff79c6">&amp;</span>loaders_args)
           .ToLocal(<span style="color:#ff79c6">&amp;</span>loader_exports)) {
    <span style="color:#ff79c6">return</span> MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span>();
  }
  CHECK(loader_exports<span style="color:#ff79c6">-&gt;</span>IsObject());
  Local<span style="color:#ff79c6">&lt;</span>Object<span style="color:#ff79c6">&gt;</span> loader_exports_obj <span style="color:#ff79c6">=</span> loader_exports.As<span style="color:#ff79c6">&lt;</span>Object<span style="color:#ff79c6">&gt;</span>();
  Local<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> internal_binding_loader <span style="color:#ff79c6">=</span>
      loader_exports_obj<span style="color:#ff79c6">-&gt;</span>Get(context(), internal_binding_string())
          .ToLocalChecked();
  CHECK(internal_binding_loader<span style="color:#ff79c6">-&gt;</span>IsFunction());
  set_internal_binding_loader(internal_binding_loader.As<span style="color:#ff79c6">&lt;</span>Function<span style="color:#ff79c6">&gt;</span>());
  Local<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> require <span style="color:#ff79c6">=</span>
      loader_exports_obj<span style="color:#ff79c6">-&gt;</span>Get(context(), require_string()).ToLocalChecked();
  CHECK(require<span style="color:#ff79c6">-&gt;</span>IsFunction());
  set_native_module_require(require.As<span style="color:#ff79c6">&lt;</span>Function<span style="color:#ff79c6">&gt;</span>());

  <span style="color:#ff79c6">return</span> scope.Escape(loader_exports);
}
</code></pre></div><p>根据注释，流程分为了两步：<code>Create binding loaders</code>和<code>Bootstrap internal loaders</code>，第一步准备了两个参数<code>loaders_params</code>和<code>loaders_args</code>供第二步使用，两者的内容是相同的，区别是<code>params</code>是字符串形式的，<code>args</code>是真正的对象。其中，</p>
<ul>
<li><code>process</code>参数就是<code>Node.js</code>中的全局对象<code>process</code></li>
<li><code>getLinkedBinding</code>和<code>getInternalBinding</code>实现<code>JS</code>端获取<code>C++</code>模块，两者都是<code>V8</code>的<code>FunctionTemplate</code>，实现<code>JS</code>函数与<code>C++</code>函数的关联，以便<code>JS</code>调用<code>C++</code>函数。</li>
<li><code> primordials</code>是<code>JS</code>常用的内置对象，<code>Error, Symbol, String, Boolean</code>等。</li>
</ul>
<p>之前说到，内建模块在<code>InitializeNodeWithArgs</code>中被注册到一个链表上，然后有一个<code>GetInternalBinding</code>方法，用来取出内建模块。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_binding.cc
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">GetInternalBinding</span>(<span style="color:#ff79c6">const</span> FunctionCallbackInfo<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;&amp;</span> args) {
  Environment<span style="color:#ff79c6">*</span> env <span style="color:#ff79c6">=</span> Environment<span style="color:#ff79c6">::</span>GetCurrent(args);

  CHECK(args[<span style="color:#bd93f9">0</span>]<span style="color:#ff79c6">-&gt;</span>IsString());

  Local<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;</span> module <span style="color:#ff79c6">=</span> args[<span style="color:#bd93f9">0</span>].As<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;</span>();
  node<span style="color:#ff79c6">::</span>Utf8Value module_v(env<span style="color:#ff79c6">-&gt;</span>isolate(), module);
  Local<span style="color:#ff79c6">&lt;</span>Object<span style="color:#ff79c6">&gt;</span> exports;

  node_module<span style="color:#ff79c6">*</span> mod <span style="color:#ff79c6">=</span> FindModule(modlist_internal, <span style="color:#ff79c6">*</span>module_v, NM_F_INTERNAL);
  <span style="color:#ff79c6">if</span> (mod <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nullptr</span>) {
    exports <span style="color:#ff79c6">=</span> InitModule(env, mod, module);
  } <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>strcmp(<span style="color:#ff79c6">*</span>module_v, <span style="color:#f1fa8c">&#34;constants&#34;</span>)) {
    exports <span style="color:#ff79c6">=</span> Object<span style="color:#ff79c6">::</span>New(env<span style="color:#ff79c6">-&gt;</span>isolate());
    CHECK(
        exports<span style="color:#ff79c6">-&gt;</span>SetPrototype(env<span style="color:#ff79c6">-&gt;</span>context(), Null(env<span style="color:#ff79c6">-&gt;</span>isolate())).FromJust());
    DefineConstants(env<span style="color:#ff79c6">-&gt;</span>isolate(), exports);
  } <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>strcmp(<span style="color:#ff79c6">*</span>module_v, <span style="color:#f1fa8c">&#34;natives&#34;</span>)) {
    exports <span style="color:#ff79c6">=</span> native_module<span style="color:#ff79c6">::</span>NativeModuleEnv<span style="color:#ff79c6">::</span>GetSourceObject(env<span style="color:#ff79c6">-&gt;</span>context());
    <span style="color:#6272a4">// Legacy feature: process.binding(&#39;natives&#39;).config contains stringified
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// config.gypi
</span><span style="color:#6272a4"></span>    CHECK(exports
              <span style="color:#ff79c6">-&gt;</span>Set(env<span style="color:#ff79c6">-&gt;</span>context(),
                    env<span style="color:#ff79c6">-&gt;</span>config_string(),
                    native_module<span style="color:#ff79c6">::</span>NativeModuleEnv<span style="color:#ff79c6">::</span>GetConfigString(
                        env<span style="color:#ff79c6">-&gt;</span>isolate()))
              .FromJust());
  } <span style="color:#ff79c6">else</span> {
    <span style="color:#8be9fd">char</span> errmsg[<span style="color:#bd93f9">1024</span>];
    snprintf(errmsg, <span style="color:#ff79c6">sizeof</span>(errmsg), <span style="color:#f1fa8c">&#34;No such module: %s&#34;</span>, <span style="color:#ff79c6">*</span>module_v);
    <span style="color:#ff79c6">return</span> THROW_ERR_INVALID_MODULE(env, errmsg);
  }

  args.GetReturnValue().Set(exports);
}
</code></pre></div><p>首先通过一个<code>FindModule</code>函数找到模块，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_binding.cc
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">inline</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">node_module</span><span style="color:#ff79c6">*</span> <span style="color:#50fa7b">FindModule</span>(<span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">node_module</span><span style="color:#ff79c6">*</span> list,
                                      <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> name,
                                      <span style="color:#8be9fd">int</span> flag) {
  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">node_module</span><span style="color:#ff79c6">*</span> mp;

  <span style="color:#ff79c6">for</span> (mp <span style="color:#ff79c6">=</span> list; mp <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nullptr</span>; mp <span style="color:#ff79c6">=</span> mp<span style="color:#ff79c6">-&gt;</span>nm_link) {
    <span style="color:#ff79c6">if</span> (strcmp(mp<span style="color:#ff79c6">-&gt;</span>nm_modname, name) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) <span style="color:#ff79c6">break</span>;
  }

  CHECK(mp <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nullptr</span> <span style="color:#ff79c6">||</span> (mp<span style="color:#ff79c6">-&gt;</span>nm_flags <span style="color:#ff79c6">&amp;</span> flag) <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span>);
  <span style="color:#ff79c6">return</span> mp;
}
</code></pre></div><p>之后通过<code>InitModule</code>初始化模块，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_binding.cc
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">static</span> Local<span style="color:#ff79c6">&lt;</span>Object<span style="color:#ff79c6">&gt;</span> InitModule(Environment<span style="color:#ff79c6">*</span> env,
                                node_module<span style="color:#ff79c6">*</span> mod,
                                Local<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;</span> module) {
  <span style="color:#6272a4">// Internal bindings don&#39;t have a &#34;module&#34; object, only exports.
</span><span style="color:#6272a4"></span>  Local<span style="color:#ff79c6">&lt;</span>Function<span style="color:#ff79c6">&gt;</span> ctor <span style="color:#ff79c6">=</span> env<span style="color:#ff79c6">-&gt;</span>binding_data_ctor_template()
                             <span style="color:#ff79c6">-&gt;</span>GetFunction(env<span style="color:#ff79c6">-&gt;</span>context())
                             .ToLocalChecked();
  Local<span style="color:#ff79c6">&lt;</span>Object<span style="color:#ff79c6">&gt;</span> exports <span style="color:#ff79c6">=</span> ctor<span style="color:#ff79c6">-&gt;</span>NewInstance(env<span style="color:#ff79c6">-&gt;</span>context()).ToLocalChecked();
  CHECK_NULL(mod<span style="color:#ff79c6">-&gt;</span>nm_register_func);
  CHECK_NOT_NULL(mod<span style="color:#ff79c6">-&gt;</span>nm_context_register_func);
  Local<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> unused <span style="color:#ff79c6">=</span> Undefined(env<span style="color:#ff79c6">-&gt;</span>isolate());
  mod<span style="color:#ff79c6">-&gt;</span>nm_context_register_func(exports, unused, env<span style="color:#ff79c6">-&gt;</span>context(), mod<span style="color:#ff79c6">-&gt;</span>nm_priv);
  <span style="color:#ff79c6">return</span> exports;
}
</code></pre></div><p>初始化时，调用传入的<code>mod</code>的<code>nm_context_register_func</code>方法注册模块，这里以<code>async_wrap</code>模块为例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// async_wrap.cc
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> AsyncWrap<span style="color:#ff79c6">::</span>Initialize(Local<span style="color:#ff79c6">&lt;</span>Object<span style="color:#ff79c6">&gt;</span> target,
                           Local<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> unused,
                           Local<span style="color:#ff79c6">&lt;</span>Context<span style="color:#ff79c6">&gt;</span> context,
                           <span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> priv) {
  Environment<span style="color:#ff79c6">*</span> env <span style="color:#ff79c6">=</span> Environment<span style="color:#ff79c6">::</span>GetCurrent(context);
  Isolate<span style="color:#ff79c6">*</span> isolate <span style="color:#ff79c6">=</span> env<span style="color:#ff79c6">-&gt;</span>isolate();
  HandleScope <span style="color:#50fa7b">scope</span>(isolate);

  env<span style="color:#ff79c6">-&gt;</span>SetMethod(target, <span style="color:#f1fa8c">&#34;setupHooks&#34;</span>, SetupHooks);
  env<span style="color:#ff79c6">-&gt;</span>SetMethod(target, <span style="color:#f1fa8c">&#34;setCallbackTrampoline&#34;</span>, SetCallbackTrampoline);
  env<span style="color:#ff79c6">-&gt;</span>SetMethod(target, <span style="color:#f1fa8c">&#34;pushAsyncContext&#34;</span>, PushAsyncContext);
  env<span style="color:#ff79c6">-&gt;</span>SetMethod(target, <span style="color:#f1fa8c">&#34;popAsyncContext&#34;</span>, PopAsyncContext);
  env<span style="color:#ff79c6">-&gt;</span>SetMethod(target, <span style="color:#f1fa8c">&#34;executionAsyncResource&#34;</span>, ExecutionAsyncResource);
  env<span style="color:#ff79c6">-&gt;</span>SetMethod(target, <span style="color:#f1fa8c">&#34;clearAsyncIdStack&#34;</span>, ClearAsyncIdStack);
  env<span style="color:#ff79c6">-&gt;</span>SetMethod(target, <span style="color:#f1fa8c">&#34;queueDestroyAsyncId&#34;</span>, QueueDestroyAsyncId);
  env<span style="color:#ff79c6">-&gt;</span>SetMethod(target, <span style="color:#f1fa8c">&#34;enablePromiseHook&#34;</span>, EnablePromiseHook);
  env<span style="color:#ff79c6">-&gt;</span>SetMethod(target, <span style="color:#f1fa8c">&#34;disablePromiseHook&#34;</span>, DisablePromiseHook);
  env<span style="color:#ff79c6">-&gt;</span>SetMethod(target, <span style="color:#f1fa8c">&#34;registerDestroyHook&#34;</span>, RegisterDestroyHook);
  <span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span>}
</code></pre></div><p>调用初始化函数后，传入的<code>exports</code>上就挂载了<code>setupHooks</code>,<code>setCallbackTrampoline</code>等函数，之后返回<code>exports</code>。</p>
<p>至此，内建函数的装载就完成了。</p>
<p>参数准备完毕后，就调用<code>!ExecuteBootstrapper</code>执行<code>internal/bootstrap/loaders</code>，首先看一下<code>!ExecuteBootstrapper</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node.cc
</span><span style="color:#6272a4"></span>MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> ExecuteBootstrapper(Environment<span style="color:#ff79c6">*</span> env,
                                      <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> id,
                                      std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Local<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;&gt;*</span> parameters,
                                      std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Local<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;&gt;*</span> arguments) {
  EscapableHandleScope <span style="color:#50fa7b">scope</span>(env<span style="color:#ff79c6">-&gt;</span>isolate());
  MaybeLocal<span style="color:#ff79c6">&lt;</span>Function<span style="color:#ff79c6">&gt;</span> maybe_fn <span style="color:#ff79c6">=</span>
      NativeModuleEnv<span style="color:#ff79c6">::</span>LookupAndCompile(env<span style="color:#ff79c6">-&gt;</span>context(), id, parameters, env);

  Local<span style="color:#ff79c6">&lt;</span>Function<span style="color:#ff79c6">&gt;</span> fn;
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>maybe_fn.ToLocal(<span style="color:#ff79c6">&amp;</span>fn)) {
    <span style="color:#ff79c6">return</span> MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span>();
  }

  MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> result <span style="color:#ff79c6">=</span> fn<span style="color:#ff79c6">-&gt;</span>Call(env<span style="color:#ff79c6">-&gt;</span>context(),
                                      Undefined(env<span style="color:#ff79c6">-&gt;</span>isolate()),
                                      arguments<span style="color:#ff79c6">-&gt;</span>size(),
                                      arguments<span style="color:#ff79c6">-&gt;</span>data());

  <span style="color:#6272a4">// If there was an error during bootstrap, it must be unrecoverable
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// (e.g. max call stack exceeded). Clear the stack so that the
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// AsyncCallbackScope destructor doesn&#39;t fail on the id check.
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// There are only two ways to have a stack size &gt; 1: 1) the user manually
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// called MakeCallback or 2) user awaited during bootstrap, which triggered
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// _tickCallback().
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span> (result.IsEmpty()) {
    env<span style="color:#ff79c6">-&gt;</span>async_hooks()<span style="color:#ff79c6">-&gt;</span>clear_async_id_stack();
  }

  <span style="color:#ff79c6">return</span> scope.EscapeMaybe(result);
}
</code></pre></div><p>可以看到，这里调用<code>LookupAndCompile</code>， 将文件路径字符串传入当作<code>id</code>执行，并返回<code>maybe_fn</code>调用<code>call</code>执行真正意义上的第一个<code>JS</code>文件。</p>
<p>看一下<code>LookupAndCompile</code>，这里的主干代码由秋衣大佬做了修正，具体可以看<a href="https://github.com/nodejs/node/pull/27160"  target="_blank" rel="noopener" >https://github.com/nodejs/node/pull/27160</a>，就不看这个代理类的相关代码了，直接跳到<code>LookupAndCompile</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_native_module.cc
</span><span style="color:#6272a4"></span>MaybeLocal<span style="color:#ff79c6">&lt;</span>Function<span style="color:#ff79c6">&gt;</span> NativeModuleLoader<span style="color:#ff79c6">::</span>LookupAndCompile(
    Local<span style="color:#ff79c6">&lt;</span>Context<span style="color:#ff79c6">&gt;</span> context,
    <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> id,
    std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Local<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;&gt;*</span> parameters,
    NativeModuleLoader<span style="color:#ff79c6">::</span>Result<span style="color:#ff79c6">*</span> result) {
  Isolate<span style="color:#ff79c6">*</span> isolate <span style="color:#ff79c6">=</span> context<span style="color:#ff79c6">-&gt;</span>GetIsolate();
  EscapableHandleScope <span style="color:#50fa7b">scope</span>(isolate);

  Local<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;</span> source;
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>LoadBuiltinModuleSource(isolate, id).ToLocal(<span style="color:#ff79c6">&amp;</span>source)) {
    <span style="color:#ff79c6">return</span> {};
  }

  std<span style="color:#ff79c6">::</span>string filename_s <span style="color:#ff79c6">=</span> std<span style="color:#ff79c6">::</span>string(<span style="color:#f1fa8c">&#34;node:&#34;</span>) <span style="color:#ff79c6">+</span> id;
  Local<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;</span> filename <span style="color:#ff79c6">=</span>
      OneByteString(isolate, filename_s.c_str(), filename_s.size());
  Local<span style="color:#ff79c6">&lt;</span>Integer<span style="color:#ff79c6">&gt;</span> line_offset <span style="color:#ff79c6">=</span> Integer<span style="color:#ff79c6">::</span>New(isolate, <span style="color:#bd93f9">0</span>);
  Local<span style="color:#ff79c6">&lt;</span>Integer<span style="color:#ff79c6">&gt;</span> column_offset <span style="color:#ff79c6">=</span> Integer<span style="color:#ff79c6">::</span>New(isolate, <span style="color:#bd93f9">0</span>);
  ScriptOrigin <span style="color:#50fa7b">origin</span>(filename, line_offset, column_offset, True(isolate));

  ScriptCompiler<span style="color:#ff79c6">::</span>CachedData<span style="color:#ff79c6">*</span> cached_data <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">nullptr</span>;
  {
    <span style="color:#6272a4">// Note: The lock here should not extend into the
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// `CompileFunctionInContext()` call below, because this function may
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// recurse if there is a syntax error during bootstrap (because the fatal
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// exception handler is invoked, which may load built-in modules).
</span><span style="color:#6272a4"></span>    Mutex<span style="color:#ff79c6">::</span>ScopedLock lock(code_cache_mutex_);
    <span style="color:#ff79c6">auto</span> cache_it <span style="color:#ff79c6">=</span> code_cache_.find(id);
    <span style="color:#ff79c6">if</span> (cache_it <span style="color:#ff79c6">!=</span> code_cache_.end()) {
      <span style="color:#6272a4">// Transfer ownership to ScriptCompiler::Source later.
</span><span style="color:#6272a4"></span>      cached_data <span style="color:#ff79c6">=</span> cache_it<span style="color:#ff79c6">-&gt;</span>second.release();
      code_cache_.erase(cache_it);
    }
  }

  <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">bool</span> has_cache <span style="color:#ff79c6">=</span> cached_data <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nullptr</span>;
  ScriptCompiler<span style="color:#ff79c6">::</span>CompileOptions options <span style="color:#ff79c6">=</span>
      has_cache <span style="color:#ff79c6">?</span> ScriptCompiler<span style="color:#ff79c6">::</span><span style="color:#8be9fd;font-style:italic">kConsumeCodeCache</span>
                : ScriptCompiler<span style="color:#ff79c6">::</span>kEagerCompile;
  ScriptCompiler<span style="color:#ff79c6">::</span>Source script_source(source, origin, cached_data);

  MaybeLocal<span style="color:#ff79c6">&lt;</span>Function<span style="color:#ff79c6">&gt;</span> maybe_fun <span style="color:#ff79c6">=</span>
      ScriptCompiler<span style="color:#ff79c6">::</span>CompileFunctionInContext(context,
                                               <span style="color:#ff79c6">&amp;</span>script_source,
                                               parameters<span style="color:#ff79c6">-&gt;</span>size(),
                                               parameters<span style="color:#ff79c6">-&gt;</span>data(),
                                               <span style="color:#bd93f9">0</span>,
                                               <span style="color:#ff79c6">nullptr</span>,
                                               options);

  <span style="color:#6272a4">// This could fail when there are early errors in the native modules,
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// e.g. the syntax errors
</span><span style="color:#6272a4"></span>  Local<span style="color:#ff79c6">&lt;</span>Function<span style="color:#ff79c6">&gt;</span> fun;
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>maybe_fun.ToLocal(<span style="color:#ff79c6">&amp;</span>fun)) {
    <span style="color:#6272a4">// In the case of early errors, v8 is already capable of
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// decorating the stack for us - note that we use CompileFunctionInContext
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// so there is no need to worry about wrappers.
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> MaybeLocal<span style="color:#ff79c6">&lt;</span>Function<span style="color:#ff79c6">&gt;</span>();
  }

  <span style="color:#6272a4">// XXX(joyeecheung): this bookkeeping is not exactly accurate because
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// it only starts after the Environment is created, so the per_context.js
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// will never be in any of these two sets, but the two sets are only for
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// testing anyway.
</span><span style="color:#6272a4"></span>
  <span style="color:#ff79c6">*</span>result <span style="color:#ff79c6">=</span> (has_cache <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>script_source.GetCachedData()<span style="color:#ff79c6">-&gt;</span>rejected)
                <span style="color:#ff79c6">?</span> Result<span style="color:#ff79c6">::</span><span style="color:#8be9fd;font-style:italic">kWithCache</span>
                : Result<span style="color:#ff79c6">::</span>kWithoutCache;
  <span style="color:#6272a4">// Generate new cache for next compilation
</span><span style="color:#6272a4"></span>  std<span style="color:#ff79c6">::</span>unique_ptr<span style="color:#ff79c6">&lt;</span>ScriptCompiler<span style="color:#ff79c6">::</span>CachedData<span style="color:#ff79c6">&gt;</span> new_cached_data(
      ScriptCompiler<span style="color:#ff79c6">::</span>CreateCodeCacheForFunction(fun));
  CHECK_NOT_NULL(new_cached_data);

  {
    Mutex<span style="color:#ff79c6">::</span>ScopedLock lock(code_cache_mutex_);
    <span style="color:#6272a4">// The old entry should&#39;ve been erased by now so we can just emplace.
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// If another thread did the same thing in the meantime, that should not
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// be an issue.
</span><span style="color:#6272a4"></span>    code_cache_.emplace(id, std<span style="color:#ff79c6">::</span>move(new_cached_data));
  }

  <span style="color:#ff79c6">return</span> scope.Escape(fun);
}
</code></pre></div><p>首先调用<code>LoadBuiltinModuleSource</code>加载文件代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node_native_module.cc
</span><span style="color:#6272a4"></span>MaybeLocal<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;</span> NativeModuleLoader<span style="color:#ff79c6">::</span>LoadBuiltinModuleSource(Isolate<span style="color:#ff79c6">*</span> isolate,
                                                               <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> id) {
<span style="color:#ff79c6">#ifdef NODE_BUILTIN_MODULES_PATH
</span><span style="color:#ff79c6"></span>  std<span style="color:#ff79c6">::</span>string filename <span style="color:#ff79c6">=</span> OnDiskFileName(id);

  uv_fs_t req;
  uv_file file <span style="color:#ff79c6">=</span>
      uv_fs_open(<span style="color:#ff79c6">nullptr</span>, <span style="color:#ff79c6">&amp;</span>req, filename.c_str(), O_RDONLY, <span style="color:#bd93f9">0</span>, <span style="color:#ff79c6">nullptr</span>);
  CHECK_GE(req.result, <span style="color:#bd93f9">0</span>);
  uv_fs_req_cleanup(<span style="color:#ff79c6">&amp;</span>req);

  <span style="color:#ff79c6">auto</span> defer_close <span style="color:#ff79c6">=</span> OnScopeLeave([file]() {
    uv_fs_t close_req;
    CHECK_EQ(<span style="color:#bd93f9">0</span>, uv_fs_close(<span style="color:#ff79c6">nullptr</span>, <span style="color:#ff79c6">&amp;</span>close_req, file, <span style="color:#ff79c6">nullptr</span>));
    uv_fs_req_cleanup(<span style="color:#ff79c6">&amp;</span>close_req);
  });

  std<span style="color:#ff79c6">::</span>string contents;
  <span style="color:#8be9fd">char</span> buffer[<span style="color:#bd93f9">4096</span>];
  uv_buf_t buf <span style="color:#ff79c6">=</span> uv_buf_init(buffer, <span style="color:#ff79c6">sizeof</span>(buffer));

  <span style="color:#ff79c6">while</span> (<span style="color:#8be9fd;font-style:italic">true</span>) {
    <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">int</span> r <span style="color:#ff79c6">=</span>
        uv_fs_read(<span style="color:#ff79c6">nullptr</span>, <span style="color:#ff79c6">&amp;</span>req, file, <span style="color:#ff79c6">&amp;</span>buf, <span style="color:#bd93f9">1</span>, contents.length(), <span style="color:#ff79c6">nullptr</span>);
    CHECK_GE(req.result, <span style="color:#bd93f9">0</span>);
    uv_fs_req_cleanup(<span style="color:#ff79c6">&amp;</span>req);
    <span style="color:#ff79c6">if</span> (r <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">0</span>) {
      <span style="color:#ff79c6">break</span>;
    }
    contents.append(buf.base, r);
  }

  <span style="color:#ff79c6">return</span> String<span style="color:#ff79c6">::</span>NewFromUtf8(
      isolate, contents.c_str(), v8<span style="color:#ff79c6">::</span>NewStringType<span style="color:#ff79c6">::</span>kNormal, contents.length());
<span style="color:#ff79c6">#else
</span><span style="color:#ff79c6"></span>  <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">auto</span> source_it <span style="color:#ff79c6">=</span> source_.find(id);
  CHECK_NE(source_it, source_.end());
  <span style="color:#ff79c6">return</span> source_it<span style="color:#ff79c6">-&gt;</span>second.ToStringChecked(isolate);
<span style="color:#ff79c6">#endif  </span><span style="color:#6272a4">// NODE_BUILTIN_MODULES_PATH
</span><span style="color:#6272a4"></span>}
</code></pre></div><p>这里加载本地文件使用了<code>libuv</code>相关的函数，之后调用<code>CompileFunctionInContext</code>将之前的文件代码和含有<code>getLinkedBinding</code>等方法的参数包裹起来形成一个可执行函数，执行这个函数就等同于执行<code>internal/bootstrap/loaders</code>。</p>
<p>分析完成如何编译<code>internal/bootstrap/loaders</code>之后，进入这个文件看看。</p>
<p>注释写得很长很详细，这里概括一下。</p>
<p>这个文件创建了<code>native module</code>加载器，并且给其通过<code>binding loaders</code>调用内建函数的能立。而且指出这里和<code>CommonJS Module</code>和<code>ES Module</code>是不同的机制。<code>native module</code>就是指<code>lib/**/*.js</code>和<code>*deps/**/\*.js*</code>。所有核心模块都是通过<code>js2c.py</code>生成的<code>node_javascript.cc</code>编译到二进制文件中，因此调用时不需要消耗<code>I/O</code>。</p>
<p>文件首先定义了<code>process</code>上的<code>moduleLoadList</code>属性，用来表示已加载的模块。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#ff79c6">const</span> moduleLoadList <span style="color:#ff79c6">=</span> [];
ObjectDefineProperty(process, <span style="color:#f1fa8c">&#39;moduleLoadList&#39;</span>, {
  value<span style="color:#ff79c6">:</span> moduleLoadList,
  configurable<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">true</span>,
  enumerable<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">true</span>,
  writable<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">false</span>
});
</code></pre></div><p>之后定义了<code>binding</code>和<code>_linkedBinding</code>方法，分别通过<code>internalBinding</code>方法和<code>getLinkedBinding</code>方法获取内建模块。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">process.binding <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> binding(module) {
  module <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">String</span>(module);
  <span style="color:#6272a4">// Deprecated specific process.binding() modules, but not all, allow
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// selective fallback to internalBinding for the deprecated ones.
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span> (internalBindingWhitelist.has(module)) {
    <span style="color:#ff79c6">return</span> internalBinding(module);
  }
  <span style="color:#6272a4">// eslint-disable-next-line no-restricted-syntax
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> <span style="color:#8be9fd;font-style:italic">Error</span>(<span style="color:#f1fa8c">`No such module: </span><span style="color:#f1fa8c">${</span>module<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">`</span>);
};
process._linkedBinding <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> _linkedBinding(module) {
  module <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">String</span>(module);
  <span style="color:#8be9fd;font-style:italic">let</span> mod <span style="color:#ff79c6">=</span> bindingObj[module];
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">typeof</span> mod <span style="color:#ff79c6">!==</span> <span style="color:#f1fa8c">&#39;object&#39;</span>)
    mod <span style="color:#ff79c6">=</span> bindingObj[module] <span style="color:#ff79c6">=</span> getLinkedBinding(module);
  <span style="color:#ff79c6">return</span> mod;
};
</code></pre></div><p>之后创建了<code>NativeModule</code>类，提供了内部<code>JS</code>模块的抽象，用于加载被写入<code>node_javascript.cc</code>的<code>JS</code>模块。</p>
<p>之后解释了<code>require</code>的机制。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#ff79c6">const</span> loaderExports <span style="color:#ff79c6">=</span> {
  internalBinding,
  NativeModule,
  require<span style="color:#ff79c6">:</span> nativeModuleRequire
};

<span style="color:#8be9fd;font-style:italic">function</span> nativeModuleRequire(id) {
  <span style="color:#ff79c6">if</span> (id <span style="color:#ff79c6">===</span> loaderId) {
    <span style="color:#ff79c6">return</span> loaderExports;
  }

  <span style="color:#ff79c6">const</span> mod <span style="color:#ff79c6">=</span> NativeModule.map.get(id);
  <span style="color:#6272a4">// Can&#39;t load the internal errors module from here, have to use a raw error.
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// eslint-disable-next-line no-restricted-syntax
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>mod) <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> TypeError(<span style="color:#f1fa8c">`Missing internal module &#39;</span><span style="color:#f1fa8c">${</span>id<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#39;`</span>);
  <span style="color:#ff79c6">return</span> mod.compileForInternalLoader();
}
</code></pre></div><p>首先根据<code>id</code>找到模块，然后调用<code>compileForInternalLoader</code>通过<code>node_native_module_env.cc</code>的<code>CompileFunction</code>函数实现对模块的装裹，同时提供了6个参数，分别是<code>exports</code>,<code>require</code>,<code>module</code>,<code>process</code>,<code>internalBinding</code>,<code>primordials</code>。</p>
<p>至此，内建模块<code>built-in module</code>以及内部<code>JS</code>模块<code>native module</code>装载完毕。</p>
<p>第一步<code>BootstrapInternalLoaders</code>结束后，执行第二步<code>BootstrapNode</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node.cc
</span><span style="color:#6272a4"></span>MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> Environment<span style="color:#ff79c6">::</span>BootstrapNode() {
  EscapableHandleScope <span style="color:#50fa7b">scope</span>(isolate_);

  Local<span style="color:#ff79c6">&lt;</span>Object<span style="color:#ff79c6">&gt;</span> global <span style="color:#ff79c6">=</span> context()<span style="color:#ff79c6">-&gt;</span>Global();
  <span style="color:#6272a4">// TODO(joyeecheung): this can be done in JS land now.
</span><span style="color:#6272a4"></span>  global<span style="color:#ff79c6">-&gt;</span>Set(context(), FIXED_ONE_BYTE_STRING(isolate_, <span style="color:#f1fa8c">&#34;global&#34;</span>), global)
      .Check();

  <span style="color:#6272a4">// process, require, internalBinding, primordials
</span><span style="color:#6272a4"></span>  std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Local<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;&gt;</span> node_params <span style="color:#ff79c6">=</span> {
      process_string(),
      require_string(),
      internal_binding_string(),
      primordials_string()};
  std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Local<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;&gt;</span> node_args <span style="color:#ff79c6">=</span> {
      process_object(),
      native_module_require(),
      internal_binding_loader(),
      primordials()};

  MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> result <span style="color:#ff79c6">=</span> ExecuteBootstrapper(
      <span style="color:#ff79c6">this</span>, <span style="color:#f1fa8c">&#34;internal/bootstrap/node&#34;</span>, <span style="color:#ff79c6">&amp;</span>node_params, <span style="color:#ff79c6">&amp;</span>node_args);

  <span style="color:#ff79c6">if</span> (result.IsEmpty()) {
    <span style="color:#ff79c6">return</span> scope.EscapeMaybe(result);
  }

  <span style="color:#6272a4">// TODO(joyeecheung): skip these in the snapshot building for workers.
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">auto</span> thread_switch_id <span style="color:#ff79c6">=</span>
      is_main_thread() <span style="color:#ff79c6">?</span> <span style="color:#f1fa8c">&#34;internal/bootstrap/switches/is_main_thread&#34;</span>
                       <span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;internal/bootstrap/switches/is_not_main_thread&#34;</span>;
  result <span style="color:#ff79c6">=</span>
      ExecuteBootstrapper(<span style="color:#ff79c6">this</span>, thread_switch_id, <span style="color:#ff79c6">&amp;</span>node_params, <span style="color:#ff79c6">&amp;</span>node_args);

  <span style="color:#ff79c6">if</span> (result.IsEmpty()) {
    <span style="color:#ff79c6">return</span> scope.EscapeMaybe(result);
  }

  <span style="color:#ff79c6">auto</span> process_state_switch_id <span style="color:#ff79c6">=</span>
      owns_process_state()
          <span style="color:#ff79c6">?</span> <span style="color:#f1fa8c">&#34;internal/bootstrap/switches/does_own_process_state&#34;</span>
          <span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;internal/bootstrap/switches/does_not_own_process_state&#34;</span>;
  result <span style="color:#ff79c6">=</span> ExecuteBootstrapper(
      <span style="color:#ff79c6">this</span>, process_state_switch_id, <span style="color:#ff79c6">&amp;</span>node_params, <span style="color:#ff79c6">&amp;</span>node_args);

  <span style="color:#ff79c6">if</span> (result.IsEmpty()) {
    <span style="color:#ff79c6">return</span> scope.EscapeMaybe(result);
  }

  Local<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;</span> env_string <span style="color:#ff79c6">=</span> FIXED_ONE_BYTE_STRING(isolate_, <span style="color:#f1fa8c">&#34;env&#34;</span>);
  Local<span style="color:#ff79c6">&lt;</span>Object<span style="color:#ff79c6">&gt;</span> env_var_proxy;
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>CreateEnvVarProxy(context(), isolate_).ToLocal(<span style="color:#ff79c6">&amp;</span>env_var_proxy) <span style="color:#ff79c6">||</span>
      process_object()<span style="color:#ff79c6">-&gt;</span>Set(context(), env_string, env_var_proxy).IsNothing()) {
    <span style="color:#ff79c6">return</span> MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span>();
  }

  <span style="color:#ff79c6">return</span> scope.EscapeMaybe(result);
}
</code></pre></div><p>首先在<code>context</code>上设置了一个<code>global</code>代理，它定义在<code>deps\v8\src\objects\js-objects.h</code>，并且可以通过在<code>Node</code>层调用<code>global</code>对象修改底层的<code>global</code>对象。</p>
<p>之后同样的，调用<code>ExecuteBootstrapper</code>，并将<code>env</code>，<code>internal/bootstrap/node</code>作为<code>id</code>，<code>node_params</code>以及<code>node_args</code>传入，不过这里参数有所改变，分别是<code>native_module_require</code>和<code>internal_binding_loader</code>。</p>
<p><code>ExecuteBootstrapper</code>之前分析过了，这里直接看一下<code>lib\internal\bootstrap\node.js</code>。</p>
<p>同样的，这里注释很详细，大体概括一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// Hello, and welcome to hacking node.js!
</span><span style="color:#6272a4">//
</span><span style="color:#6272a4">// This file is invoked by `node::RunBootstrapping()` in `src/node.cc`, and is
</span><span style="color:#6272a4">// responsible for setting up node.js core before executing main scripts
</span><span style="color:#6272a4">// under `lib/internal/main/`.
</span><span style="color:#6272a4">//
</span><span style="color:#6272a4">// This file is expected not to perform any asynchronous operations itself
</span><span style="color:#6272a4">// when being executed - those should be done in either
</span><span style="color:#6272a4">// `lib/internal/bootstrap/pre_execution.js` or in main scripts. The majority
</span><span style="color:#6272a4">// of the code here focuses on setting up the global proxy and the process
</span><span style="color:#6272a4">// object in a synchronous manner.
</span><span style="color:#6272a4">// As special caution is given to the performance of the startup process,
</span><span style="color:#6272a4">// many dependencies are invoked lazily.
</span></code></pre></div><p>第一句很有趣，<code>Hello, and welcome to hacking node.js!</code>。</p>
<p>这个文件只做同步操作，并且指出处理异步操作的位置<code>lib/internal/bootstrap/pre_execution.js</code>，之后说明，此文件主要是设置<code>global</code>代理和<code>process</code>对象，并且该文件启动了主线程和工作线程，这个<code>worker threads</code>主要用在<code>CPU</code>密集的场景，并且每个<code>worker thread</code>拥有独立的<code>V8 ioslate</code>，<code>libuv</code>以及<code>event loop</code>，有机会再展开说。</p>
<p>之后启动了主线程以及工作线程，然后设置了<code>global</code>对象和<code>process</code>对象上的一些属性，包括<code>global.URL, global.clearInterval, global.setInterval</code>等等，最后设置了异常回调以及任务队列<code>TaskQueue</code>。</p>
<p><code>CreateMainEnvironment</code>完成一大堆工作之后，调用<code>LoadEnvironment</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// environment.cc
</span><span style="color:#6272a4"></span>MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> LoadEnvironment(
    Environment<span style="color:#ff79c6">*</span> env,
    StartExecutionCallback cb,
    std<span style="color:#ff79c6">::</span>unique_ptr<span style="color:#ff79c6">&lt;</span>InspectorParentHandle<span style="color:#ff79c6">&gt;</span> removeme) {
  env<span style="color:#ff79c6">-&gt;</span>InitializeLibuv();
  env<span style="color:#ff79c6">-&gt;</span>InitializeDiagnostics();

  <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">StartExecution</span>(env, cb);
}
</code></pre></div><p><code>LoadEnvironment</code>首先是初始化<code>libuv</code>和异常诊断程序，然后执行启动<code>StartExecution</code>。</p>
<p>这个<code>StartExecution</code>函数实现的就是根据用户的启动参数，来以不同模式启动，并执行对应的启动文件。比如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node.cc
</span><span style="color:#6272a4"></span>std<span style="color:#ff79c6">::</span>string first_argv;
<span style="color:#ff79c6">if</span> (env<span style="color:#ff79c6">-&gt;</span>argv().size() <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">1</span>) {
  first_argv <span style="color:#ff79c6">=</span> env<span style="color:#ff79c6">-&gt;</span>argv()[<span style="color:#bd93f9">1</span>];
}
<span style="color:#ff79c6">if</span> (first_argv <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#34;inspect&#34;</span>) {
  <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">StartExecution</span>(env, <span style="color:#f1fa8c">&#34;internal/main/inspect&#34;</span>);
}
<span style="color:#ff79c6">if</span> (per_process<span style="color:#ff79c6">::</span>cli_options<span style="color:#ff79c6">-&gt;</span>print_help) {
  <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">StartExecution</span>(env, <span style="color:#f1fa8c">&#34;internal/main/print_help&#34;</span>);
}
<span style="color:#ff79c6">if</span> (env<span style="color:#ff79c6">-&gt;</span>options()<span style="color:#ff79c6">-&gt;</span>prof_process) {
  <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">StartExecution</span>(env, <span style="color:#f1fa8c">&#34;internal/main/prof_process&#34;</span>);
}
<span style="color:#6272a4">// -e/--eval without -i/--interactive
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">if</span> (env<span style="color:#ff79c6">-&gt;</span>options()<span style="color:#ff79c6">-&gt;</span>has_eval_string <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>env<span style="color:#ff79c6">-&gt;</span>options()<span style="color:#ff79c6">-&gt;</span>force_repl) {
  <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">StartExecution</span>(env, <span style="color:#f1fa8c">&#34;internal/main/eval_string&#34;</span>);
}
<span style="color:#ff79c6">if</span> (env<span style="color:#ff79c6">-&gt;</span>options()<span style="color:#ff79c6">-&gt;</span>syntax_check_only) {
  <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">StartExecution</span>(env, <span style="color:#f1fa8c">&#34;internal/main/check_syntax&#34;</span>);
}
<span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>first_argv.empty() <span style="color:#ff79c6">&amp;&amp;</span> first_argv <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;-&#34;</span>) {
  <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">StartExecution</span>(env, <span style="color:#f1fa8c">&#34;internal/main/run_main_module&#34;</span>);
}
<span style="color:#ff79c6">if</span> (env<span style="color:#ff79c6">-&gt;</span>options()<span style="color:#ff79c6">-&gt;</span>force_repl <span style="color:#ff79c6">||</span> uv_guess_handle(STDIN_FILENO) <span style="color:#ff79c6">==</span> UV_TTY) {
  <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">StartExecution</span>(env, <span style="color:#f1fa8c">&#34;internal/main/repl&#34;</span>);
}
<span style="color:#ff79c6">return</span> <span style="color:#50fa7b">StartExecution</span>(env, <span style="color:#f1fa8c">&#34;internal/main/eval_stdin&#34;</span>);
</code></pre></div><p>其中<code>inspect</code>就是调试模式，下面也可以看到<code>repl</code>环境的启动模式。</p>
<p>而默认的不带参数的启动模式如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>first_argv.empty() <span style="color:#ff79c6">&amp;&amp;</span> first_argv <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;-&#34;</span>) {
  <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">StartExecution</span>(env, <span style="color:#f1fa8c">&#34;internal/main/run_main_module&#34;</span>);
}
</code></pre></div><p>看这个文件之前，先分析<code>StartExecution</code>是如何执行这个文件的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6272a4">// node.cc
</span><span style="color:#6272a4"></span>MaybeLocal<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;</span> StartExecution(Environment<span style="color:#ff79c6">*</span> env, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> main_script_id) {
  EscapableHandleScope <span style="color:#50fa7b">scope</span>(env<span style="color:#ff79c6">-&gt;</span>isolate());
  CHECK_NOT_NULL(main_script_id);

  std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Local<span style="color:#ff79c6">&lt;</span>String<span style="color:#ff79c6">&gt;&gt;</span> parameters <span style="color:#ff79c6">=</span> {
      env<span style="color:#ff79c6">-&gt;</span>process_string(),
      env<span style="color:#ff79c6">-&gt;</span>require_string(),
      env<span style="color:#ff79c6">-&gt;</span>internal_binding_string(),
      env<span style="color:#ff79c6">-&gt;</span>primordials_string(),
      FIXED_ONE_BYTE_STRING(env<span style="color:#ff79c6">-&gt;</span>isolate(), <span style="color:#f1fa8c">&#34;markBootstrapComplete&#34;</span>)};

  std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>Local<span style="color:#ff79c6">&lt;</span>Value<span style="color:#ff79c6">&gt;&gt;</span> arguments <span style="color:#ff79c6">=</span> {
      env<span style="color:#ff79c6">-&gt;</span>process_object(),
      env<span style="color:#ff79c6">-&gt;</span>native_module_require(),
      env<span style="color:#ff79c6">-&gt;</span>internal_binding_loader(),
      env<span style="color:#ff79c6">-&gt;</span>primordials(),
      env<span style="color:#ff79c6">-&gt;</span>NewFunctionTemplate(MarkBootstrapComplete)
          <span style="color:#ff79c6">-&gt;</span>GetFunction(env<span style="color:#ff79c6">-&gt;</span>context())
          .ToLocalChecked()};

  <span style="color:#ff79c6">return</span> scope.EscapeMaybe(
      ExecuteBootstrapper(env, main_script_id, <span style="color:#ff79c6">&amp;</span>parameters, <span style="color:#ff79c6">&amp;</span>arguments));
}
</code></pre></div><p>发现还是一样，传入要执行的<code>JS</code>文件作为<code>ID</code>，然后老几样，<code>process, require, pprimordials, internal_binding_loader</code>，只是少了一个<code>getLinkedBinding</code>，多了一个<code>markBootstrapComplete</code>的标记而已，然后调用<code>ExecuteBootstrapper</code>。</p>
<p>之后看一下<code>lib\internal\main\run_main_module.js</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6272a4">// lib\internal\main\run_main_module.js
</span><span style="color:#6272a4"></span><span style="color:#f1fa8c">&#39;use strict&#39;</span>;

<span style="color:#ff79c6">const</span> {
  prepareMainThreadExecution
} <span style="color:#ff79c6">=</span> require(<span style="color:#f1fa8c">&#39;internal/bootstrap/pre_execution&#39;</span>);

prepareMainThreadExecution(<span style="color:#ff79c6">true</span>);

markBootstrapComplete();

<span style="color:#6272a4">// Note: this loads the module through the ESM loader if the module is
</span><span style="color:#6272a4">// determined to be an ES module. This hangs from the CJS module loader
</span><span style="color:#6272a4">// because we currently allow monkey-patching of the module loaders
</span><span style="color:#6272a4">// in the preloaded scripts through require(&#39;module&#39;).
</span><span style="color:#6272a4">// runMain here might be monkey-patched by users in --require.
</span><span style="color:#6272a4">// XXX: the monkey-patchability here should probably be deprecated.
</span><span style="color:#6272a4"></span>require(<span style="color:#f1fa8c">&#39;internal/modules/cjs/loader&#39;</span>).Module.runMain(process.argv[<span style="color:#bd93f9">1</span>]);
</code></pre></div><p>代码很短，主要是执行<code>prepareMainThreadExecution</code>，做最后初始化工作，并标记<code>Bootstrap</code>已完成。</p>
<p>然后通过引入<code>'internal/modules/cjs/loader</code>，调用<code>runMain</code>方法执行要启动的<code>JS</code>文件，就比如<code>node index.js</code>里的<code>index.js</code>。这里执行的是其中的同步代码，异步代码会放到后续的<code>Event Loop</code>中。</p>
<p>其中有两步需要注意。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6272a4">// pre_execution.js
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">function</span> initializeCJSLoader() {
  <span style="color:#ff79c6">const</span> CJSLoader <span style="color:#ff79c6">=</span> require(<span style="color:#f1fa8c">&#39;internal/modules/cjs/loader&#39;</span>);
  CJSLoader.Module._initPaths();
  <span style="color:#6272a4">// TODO(joyeecheung): deprecate this in favor of a proper hook?
</span><span style="color:#6272a4"></span>  CJSLoader.Module.runMain <span style="color:#ff79c6">=</span>
    require(<span style="color:#f1fa8c">&#39;internal/modules/run_main&#39;</span>).executeUserEntryPoint;
}
<span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">function</span> loadPreloadModules() {
  <span style="color:#6272a4">// For user code, we preload modules if `-r` is passed
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">const</span> preloadModules <span style="color:#ff79c6">=</span> getOptionValue(<span style="color:#f1fa8c">&#39;--require&#39;</span>);
  <span style="color:#ff79c6">if</span> (preloadModules <span style="color:#ff79c6">&amp;&amp;</span> preloadModules.length <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span>) {
    <span style="color:#ff79c6">const</span> {
      Module<span style="color:#ff79c6">:</span> {
        _preloadModules
      },
    } <span style="color:#ff79c6">=</span> require(<span style="color:#f1fa8c">&#39;internal/modules/cjs/loader&#39;</span>);
    _preloadModules(preloadModules);
  }
}
</code></pre></div><p>首先是初始化<code>CJSLoader</code>，它设置了<code>CJSLoader</code>的<code>runMain</code>方法实际上为<code>'internal/modules/run_main'</code>的<code>executeUserEntryPoint</code>。</p>
<p>然后是<code>loadPreloadModules</code>，这里通过<code>CJSLoader</code>的<code>_preloadModules</code>方法加载传入的<code>require</code>。</p>
<p>这里看一下<code>_preloadModules</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6272a4">// lib\internal\modules\cjs\loader.js
</span><span style="color:#6272a4"></span>Module._preloadModules <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span>(requests) {
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>ArrayIsArray(requests))
    <span style="color:#ff79c6">return</span>;

  <span style="color:#6272a4">// Preloaded modules have a dummy parent module which is deemed to exist
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// in the current working directory. This seeds the search path for
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// preloaded modules.
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">const</span> parent <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Module(<span style="color:#f1fa8c">&#39;internal/preload&#39;</span>, <span style="color:#ff79c6">null</span>);
  <span style="color:#ff79c6">try</span> {
    parent.paths <span style="color:#ff79c6">=</span> Module._nodeModulePaths(process.cwd());
  } <span style="color:#ff79c6">catch</span> (e) {
    <span style="color:#ff79c6">if</span> (e.code <span style="color:#ff79c6">!==</span> <span style="color:#f1fa8c">&#39;ENOENT&#39;</span>) {
      <span style="color:#ff79c6">throw</span> e;
    }
  }
  <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd;font-style:italic">let</span> n <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; n <span style="color:#ff79c6">&lt;</span> requests.length; n<span style="color:#ff79c6">++</span>)
    parent.require(requests[n]);
};
</code></pre></div><p>这里构造了一个被认为存在于当前工作路径的假的模块，这为预加载的模块提供索引路径，就是说如果我们引用<code>--require</code>的预加载模块，会通过这个路径进行查找。</p>
<p>OK，回去看<code>executeUserEntryPoint</code>，启动文件就是通过这个方法执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6272a4">// lib\internal\modules\run_main.js
</span><span style="color:#6272a4"></span><span style="color:#f1fa8c">&#39;use strict&#39;</span>;

<span style="color:#ff79c6">const</span> CJSLoader <span style="color:#ff79c6">=</span> require(<span style="color:#f1fa8c">&#39;internal/modules/cjs/loader&#39;</span>);
<span style="color:#ff79c6">const</span> { Module, toRealPath, readPackageScope } <span style="color:#ff79c6">=</span> CJSLoader;
<span style="color:#ff79c6">const</span> { getOptionValue } <span style="color:#ff79c6">=</span> require(<span style="color:#f1fa8c">&#39;internal/options&#39;</span>);
<span style="color:#ff79c6">const</span> path <span style="color:#ff79c6">=</span> require(<span style="color:#f1fa8c">&#39;path&#39;</span>);

<span style="color:#8be9fd;font-style:italic">function</span> resolveMainPath(main) {
  <span style="color:#6272a4">// Note extension resolution for the main entry point can be deprecated in a
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// future major.
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// Module._findPath is monkey-patchable here.
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd;font-style:italic">let</span> mainPath <span style="color:#ff79c6">=</span> Module._findPath(path.resolve(main), <span style="color:#ff79c6">null</span>, <span style="color:#ff79c6">true</span>);
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>mainPath)
    <span style="color:#ff79c6">return</span>;

  <span style="color:#ff79c6">const</span> preserveSymlinksMain <span style="color:#ff79c6">=</span> getOptionValue(<span style="color:#f1fa8c">&#39;--preserve-symlinks-main&#39;</span>);
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>preserveSymlinksMain)
    mainPath <span style="color:#ff79c6">=</span> toRealPath(mainPath);

  <span style="color:#ff79c6">return</span> mainPath;
}

<span style="color:#8be9fd;font-style:italic">function</span> shouldUseESMLoader(mainPath) {
  <span style="color:#ff79c6">const</span> userLoader <span style="color:#ff79c6">=</span> getOptionValue(<span style="color:#f1fa8c">&#39;--experimental-loader&#39;</span>);
  <span style="color:#ff79c6">if</span> (userLoader)
    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>;
  <span style="color:#ff79c6">const</span> esModuleSpecifierResolution <span style="color:#ff79c6">=</span>
    getOptionValue(<span style="color:#f1fa8c">&#39;--experimental-specifier-resolution&#39;</span>);
  <span style="color:#ff79c6">if</span> (esModuleSpecifierResolution <span style="color:#ff79c6">===</span> <span style="color:#f1fa8c">&#39;node&#39;</span>)
    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>;
  <span style="color:#6272a4">// Determine the module format of the main
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span> (mainPath <span style="color:#ff79c6">&amp;&amp;</span> mainPath.endsWith(<span style="color:#f1fa8c">&#39;.mjs&#39;</span>))
    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>;
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>mainPath <span style="color:#ff79c6">||</span> mainPath.endsWith(<span style="color:#f1fa8c">&#39;.cjs&#39;</span>))
    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>;
  <span style="color:#ff79c6">const</span> pkg <span style="color:#ff79c6">=</span> readPackageScope(mainPath);
  <span style="color:#ff79c6">return</span> pkg <span style="color:#ff79c6">&amp;&amp;</span> pkg.data.type <span style="color:#ff79c6">===</span> <span style="color:#f1fa8c">&#39;module&#39;</span>;
}

<span style="color:#8be9fd;font-style:italic">function</span> runMainESM(mainPath) {
  <span style="color:#ff79c6">const</span> esmLoader <span style="color:#ff79c6">=</span> require(<span style="color:#f1fa8c">&#39;internal/process/esm_loader&#39;</span>);
  <span style="color:#ff79c6">const</span> { pathToFileURL } <span style="color:#ff79c6">=</span> require(<span style="color:#f1fa8c">&#39;internal/url&#39;</span>);
  handleMainPromise(esmLoader.loadESM((ESMLoader) =&gt; {
    <span style="color:#ff79c6">const</span> main <span style="color:#ff79c6">=</span> path.isAbsolute(mainPath) <span style="color:#ff79c6">?</span>
      pathToFileURL(mainPath).href <span style="color:#ff79c6">:</span> mainPath;
    <span style="color:#ff79c6">return</span> ESMLoader.<span style="color:#ff79c6">import</span>(main);
  }));
}

<span style="color:#8be9fd;font-style:italic">function</span> handleMainPromise(promise) {
  <span style="color:#6272a4">// Handle a Promise from running code that potentially does Top-Level Await.
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// In that case, it makes sense to set the exit code to a specific non-zero
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// value if the main code never finishes running.
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd;font-style:italic">function</span> handler() {
    <span style="color:#ff79c6">if</span> (process.exitCode <span style="color:#ff79c6">===</span> <span style="color:#ff79c6">undefined</span>)
      process.exitCode <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">13</span>;
  }
  process.on(<span style="color:#f1fa8c">&#39;exit&#39;</span>, handler);
  <span style="color:#ff79c6">return</span> promise.<span style="color:#ff79c6">finally</span>(() =&gt; process.off(<span style="color:#f1fa8c">&#39;exit&#39;</span>, handler));
}

<span style="color:#6272a4">// For backwards compatibility, we have to run a bunch of
</span><span style="color:#6272a4">// monkey-patchable code that belongs to the CJS loader (exposed by
</span><span style="color:#6272a4">// `require(&#39;module&#39;)`) even when the entry point is ESM.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">function</span> executeUserEntryPoint(main <span style="color:#ff79c6">=</span> process.argv[<span style="color:#bd93f9">1</span>]) {
  <span style="color:#ff79c6">const</span> resolvedMain <span style="color:#ff79c6">=</span> resolveMainPath(main);
  <span style="color:#ff79c6">const</span> useESMLoader <span style="color:#ff79c6">=</span> shouldUseESMLoader(resolvedMain);
  <span style="color:#ff79c6">if</span> (useESMLoader) {
    runMainESM(resolvedMain <span style="color:#ff79c6">||</span> main);
  } <span style="color:#ff79c6">else</span> {
    <span style="color:#6272a4">// Module._load is the monkey-patchable CJS module loader.
</span><span style="color:#6272a4"></span>    Module._load(main, <span style="color:#ff79c6">null</span>, <span style="color:#ff79c6">true</span>);
  }
}

module.exports <span style="color:#ff79c6">=</span> {
  executeUserEntryPoint,
  handleMainPromise,
};
</code></pre></div><p>这里的<code>executeUserEntryPoint</code>方法，首先是找到文件路径并判断模块类别，这里介绍一下<code>cjs</code>的导入方法。</p>
<p>首先会调用<code>Module</code>的<code>_load</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6272a4">// lib\internal\modules\cjs\loader.js
</span><span style="color:#6272a4"></span>Module._load <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span>(request, parent, isMain) {
  <span style="color:#8be9fd;font-style:italic">let</span> relResolveCacheIdentifier;
  <span style="color:#ff79c6">if</span> (parent) {
    debug(<span style="color:#f1fa8c">&#39;Module._load REQUEST %s parent: %s&#39;</span>, request, parent.id);
    <span style="color:#6272a4">// Fast path for (lazy loaded) modules in the same directory. The indirect
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// caching is required to allow cache invalidation without changing the old
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// cache key names.
</span><span style="color:#6272a4"></span>    relResolveCacheIdentifier <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">`</span><span style="color:#f1fa8c">${</span>parent.path<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">\x00</span><span style="color:#f1fa8c">${</span>request<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">`</span>;
    <span style="color:#ff79c6">const</span> filename <span style="color:#ff79c6">=</span> relativeResolveCache[relResolveCacheIdentifier];
    <span style="color:#ff79c6">if</span> (filename <span style="color:#ff79c6">!==</span> <span style="color:#ff79c6">undefined</span>) {
      <span style="color:#ff79c6">const</span> cachedModule <span style="color:#ff79c6">=</span> Module._cache[filename];
      <span style="color:#ff79c6">if</span> (cachedModule <span style="color:#ff79c6">!==</span> <span style="color:#ff79c6">undefined</span>) {
        updateChildren(parent, cachedModule, <span style="color:#ff79c6">true</span>);
        <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>cachedModule.loaded)
          <span style="color:#ff79c6">return</span> getExportsForCircularRequire(cachedModule);
        <span style="color:#ff79c6">return</span> cachedModule.exports;
      }
      <span style="color:#ff79c6">delete</span> relativeResolveCache[relResolveCacheIdentifier];
    }
  }

  <span style="color:#ff79c6">const</span> filename <span style="color:#ff79c6">=</span> Module._resolveFilename(request, parent, isMain);

  <span style="color:#ff79c6">const</span> cachedModule <span style="color:#ff79c6">=</span> Module._cache[filename];
  <span style="color:#ff79c6">if</span> (cachedModule <span style="color:#ff79c6">!==</span> <span style="color:#ff79c6">undefined</span>) {
    updateChildren(parent, cachedModule, <span style="color:#ff79c6">true</span>);
    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>cachedModule.loaded) {
      <span style="color:#ff79c6">const</span> parseCachedModule <span style="color:#ff79c6">=</span> cjsParseCache.get(cachedModule);
      <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>parseCachedModule <span style="color:#ff79c6">||</span> parseCachedModule.loaded)
        <span style="color:#ff79c6">return</span> getExportsForCircularRequire(cachedModule);
      parseCachedModule.loaded <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span>;
    } <span style="color:#ff79c6">else</span> {
      <span style="color:#ff79c6">return</span> cachedModule.exports;
    }
  }

  <span style="color:#ff79c6">const</span> mod <span style="color:#ff79c6">=</span> loadNativeModule(filename, request);
  <span style="color:#ff79c6">if</span> (mod <span style="color:#ff79c6">&amp;&amp;</span> mod.canBeRequiredByUsers) <span style="color:#ff79c6">return</span> mod.exports;

  <span style="color:#6272a4">// Don&#39;t call updateChildren(), Module constructor already does.
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">const</span> module <span style="color:#ff79c6">=</span> cachedModule <span style="color:#ff79c6">||</span> <span style="color:#ff79c6">new</span> Module(filename, parent);

  <span style="color:#ff79c6">if</span> (isMain) {
    process.mainModule <span style="color:#ff79c6">=</span> module;
    module.id <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;.&#39;</span>;
  }

  Module._cache[filename] <span style="color:#ff79c6">=</span> module;
  <span style="color:#ff79c6">if</span> (parent <span style="color:#ff79c6">!==</span> <span style="color:#ff79c6">undefined</span>) {
    relativeResolveCache[relResolveCacheIdentifier] <span style="color:#ff79c6">=</span> filename;
  }

  <span style="color:#8be9fd;font-style:italic">let</span> threw <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span>;
  <span style="color:#ff79c6">try</span> {
    <span style="color:#6272a4">// Intercept exceptions that occur during the first tick and rekey them
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// on error instance rather than module instance (which will immediately be
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// garbage collected).
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (getSourceMapsEnabled()) {
      <span style="color:#ff79c6">try</span> {
        module.load(filename);
      } <span style="color:#ff79c6">catch</span> (err) {
        rekeySourceMap(Module._cache[filename], err);
        <span style="color:#ff79c6">throw</span> err; <span style="color:#6272a4">/* node-do-not-add-exception-line */</span>
      }
    } <span style="color:#ff79c6">else</span> {
      module.load(filename);
    }
    threw <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">false</span>;
  } <span style="color:#ff79c6">finally</span> {
    <span style="color:#ff79c6">if</span> (threw) {
      <span style="color:#ff79c6">delete</span> Module._cache[filename];
      <span style="color:#ff79c6">if</span> (parent <span style="color:#ff79c6">!==</span> <span style="color:#ff79c6">undefined</span>) {
        <span style="color:#ff79c6">delete</span> relativeResolveCache[relResolveCacheIdentifier];
        <span style="color:#ff79c6">const</span> children <span style="color:#ff79c6">=</span> parent <span style="color:#ff79c6">&amp;&amp;</span> parent.children;
        <span style="color:#ff79c6">if</span> (ArrayIsArray(children)) {
          <span style="color:#ff79c6">const</span> index <span style="color:#ff79c6">=</span> children.indexOf(module);
          <span style="color:#ff79c6">if</span> (index <span style="color:#ff79c6">!==</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>) {
            children.splice(index, <span style="color:#bd93f9">1</span>);
          }
        }
      }
    } <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> (module.exports <span style="color:#ff79c6">&amp;&amp;</span>
               <span style="color:#ff79c6">!</span>isProxy(module.exports) <span style="color:#ff79c6">&amp;&amp;</span>
               ObjectGetPrototypeOf(module.exports) <span style="color:#ff79c6">===</span>
                 CircularRequirePrototypeWarningProxy) {
      ObjectSetPrototypeOf(module.exports, ObjectPrototype);
    }
  }

  <span style="color:#ff79c6">return</span> module.exports;
};
</code></pre></div><p>如果当前模块有父模块，会根据父模块找到当前模块的文件名。之后会检查模块是否有缓存，有则直接返回。下一步，会判断模块是否为<code>NativeModule</code>，如果是则直接导出。之后只会是自定义模块了，首先会根据文件名实例化一个<code>Module</code>对象并做缓存处理，然后调用<code>load</code>方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6272a4">// lib\internal\modules\cjs\loader.js
</span><span style="color:#6272a4"></span>Module.prototype.load <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span>(filename) {
  debug(<span style="color:#f1fa8c">&#39;load %j for module %j&#39;</span>, filename, <span style="color:#ff79c6">this</span>.id);

  assert(<span style="color:#ff79c6">!</span><span style="color:#ff79c6">this</span>.loaded);
  <span style="color:#ff79c6">this</span>.filename <span style="color:#ff79c6">=</span> filename;
  <span style="color:#ff79c6">this</span>.paths <span style="color:#ff79c6">=</span> Module._nodeModulePaths(path.dirname(filename));

  <span style="color:#ff79c6">const</span> extension <span style="color:#ff79c6">=</span> findLongestRegisteredExtension(filename);
  <span style="color:#6272a4">// allow .mjs to be overridden
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span> (filename.endsWith(<span style="color:#f1fa8c">&#39;.mjs&#39;</span>) <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>Module._extensions[<span style="color:#f1fa8c">&#39;.mjs&#39;</span>]) {
    <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> ERR_REQUIRE_ESM(filename);
  }
  Module._extensions[extension](<span style="color:#ff79c6">this</span>, filename);
  <span style="color:#ff79c6">this</span>.loaded <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span>;

  <span style="color:#ff79c6">const</span> ESMLoader <span style="color:#ff79c6">=</span> asyncESM.ESMLoader;
  <span style="color:#6272a4">// Create module entry at load time to snapshot exports correctly
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">const</span> exports <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.exports;
  <span style="color:#6272a4">// Preemptively cache
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">if</span> ((module<span style="color:#ff79c6">?</span>.module <span style="color:#ff79c6">===</span> <span style="color:#ff79c6">undefined</span> <span style="color:#ff79c6">||</span>
       module.module.getStatus() <span style="color:#ff79c6">&lt;</span> kEvaluated) <span style="color:#ff79c6">&amp;&amp;</span>
      <span style="color:#ff79c6">!</span>ESMLoader.cjsCache.has(<span style="color:#ff79c6">this</span>))
    ESMLoader.cjsCache.set(<span style="color:#ff79c6">this</span>, exports);
};
</code></pre></div><p>这里会根据不同的文件扩展名调用<code>Module._extension</code>方法，分别是<code>.js .json .node</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6272a4">// lib\internal\modules\cjs\loader.js
</span><span style="color:#6272a4"></span>Module._extensions[<span style="color:#f1fa8c">&#39;.js&#39;</span>] <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span>(module, filename) {
  <span style="color:#ff79c6">if</span> (filename.endsWith(<span style="color:#f1fa8c">&#39;.js&#39;</span>)) {
    <span style="color:#ff79c6">const</span> pkg <span style="color:#ff79c6">=</span> readPackageScope(filename);
    <span style="color:#6272a4">// Function require shouldn&#39;t be used in ES modules.
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (pkg <span style="color:#ff79c6">&amp;&amp;</span> pkg.data <span style="color:#ff79c6">&amp;&amp;</span> pkg.data.type <span style="color:#ff79c6">===</span> <span style="color:#f1fa8c">&#39;module&#39;</span>) {
      <span style="color:#ff79c6">const</span> parent <span style="color:#ff79c6">=</span> moduleParentCache.get(module);
      <span style="color:#ff79c6">const</span> parentPath <span style="color:#ff79c6">=</span> parent <span style="color:#ff79c6">&amp;&amp;</span> parent.filename;
      <span style="color:#ff79c6">const</span> packageJsonPath <span style="color:#ff79c6">=</span> path.resolve(pkg.path, <span style="color:#f1fa8c">&#39;package.json&#39;</span>);
      <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> ERR_REQUIRE_ESM(filename, parentPath, packageJsonPath);
    }
  }
  <span style="color:#6272a4">// If already analyzed the source, then it will be cached.
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">const</span> cached <span style="color:#ff79c6">=</span> cjsParseCache.get(module);
  <span style="color:#8be9fd;font-style:italic">let</span> content;
  <span style="color:#ff79c6">if</span> (cached <span style="color:#ff79c6">&amp;&amp;</span> cached.source) {
    content <span style="color:#ff79c6">=</span> cached.source;
    cached.source <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">undefined</span>;
  } <span style="color:#ff79c6">else</span> {
    content <span style="color:#ff79c6">=</span> fs.readFileSync(filename, <span style="color:#f1fa8c">&#39;utf8&#39;</span>);
  }
  module._compile(content, filename);
};
</code></pre></div><p>对于<code>.js</code>模块，会调用<code>fs.readFileSync</code>读取文件内容，有缓存则直接读缓存，然后调用<code>_compile</code>编译。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6272a4">// lib\internal\modules\cjs\loader.js
</span><span style="color:#6272a4"></span>Module.prototype._compile <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span>(content, filename) {
  <span style="color:#8be9fd;font-style:italic">let</span> moduleURL;
  <span style="color:#8be9fd;font-style:italic">let</span> redirects;
  <span style="color:#ff79c6">if</span> (policy<span style="color:#ff79c6">?</span>.manifest) {
    moduleURL <span style="color:#ff79c6">=</span> pathToFileURL(filename);
    redirects <span style="color:#ff79c6">=</span> policy.manifest.getDependencyMapper(moduleURL);
    policy.manifest.assertIntegrity(moduleURL, content);
  }

  maybeCacheSourceMap(filename, content, <span style="color:#ff79c6">this</span>);
  <span style="color:#ff79c6">const</span> compiledWrapper <span style="color:#ff79c6">=</span> wrapSafe(filename, content, <span style="color:#ff79c6">this</span>);

  <span style="color:#8be9fd;font-style:italic">let</span> inspectorWrapper <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">null</span>;
  <span style="color:#ff79c6">if</span> (getOptionValue(<span style="color:#f1fa8c">&#39;--inspect-brk&#39;</span>) <span style="color:#ff79c6">&amp;&amp;</span> process._eval <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">null</span>) {
    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>resolvedArgv) {
      <span style="color:#6272a4">// We enter the repl if we&#39;re not given a filename argument.
</span><span style="color:#6272a4"></span>      <span style="color:#ff79c6">if</span> (process.argv[<span style="color:#bd93f9">1</span>]) {
        <span style="color:#ff79c6">try</span> {
          resolvedArgv <span style="color:#ff79c6">=</span> Module._resolveFilename(process.argv[<span style="color:#bd93f9">1</span>], <span style="color:#ff79c6">null</span>, <span style="color:#ff79c6">false</span>);
        } <span style="color:#ff79c6">catch</span> {
          <span style="color:#6272a4">// We only expect this codepath to be reached in the case of a
</span><span style="color:#6272a4"></span>          <span style="color:#6272a4">// preloaded module (it will fail earlier with the main entry)
</span><span style="color:#6272a4"></span>          assert(ArrayIsArray(getOptionValue(<span style="color:#f1fa8c">&#39;--require&#39;</span>)));
        }
      } <span style="color:#ff79c6">else</span> {
        resolvedArgv <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;repl&#39;</span>;
      }
    }

    <span style="color:#6272a4">// Set breakpoint on module start
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (resolvedArgv <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>hasPausedEntry <span style="color:#ff79c6">&amp;&amp;</span> filename <span style="color:#ff79c6">===</span> resolvedArgv) {
      hasPausedEntry <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span>;
      inspectorWrapper <span style="color:#ff79c6">=</span> internalBinding(<span style="color:#f1fa8c">&#39;inspector&#39;</span>).callAndPauseOnStart;
    }
  }
  <span style="color:#ff79c6">const</span> dirname <span style="color:#ff79c6">=</span> path.dirname(filename);
  <span style="color:#ff79c6">const</span> require <span style="color:#ff79c6">=</span> makeRequireFunction(<span style="color:#ff79c6">this</span>, redirects);
  <span style="color:#8be9fd;font-style:italic">let</span> result;
  <span style="color:#ff79c6">const</span> exports <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.exports;
  <span style="color:#ff79c6">const</span> thisValue <span style="color:#ff79c6">=</span> exports;
  <span style="color:#ff79c6">const</span> module <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>;
  <span style="color:#ff79c6">if</span> (requireDepth <span style="color:#ff79c6">===</span> <span style="color:#bd93f9">0</span>) statCache <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Map();
  <span style="color:#ff79c6">if</span> (inspectorWrapper) {
    result <span style="color:#ff79c6">=</span> inspectorWrapper(compiledWrapper, thisValue, exports,
                              require, module, filename, dirname);
  } <span style="color:#ff79c6">else</span> {
    result <span style="color:#ff79c6">=</span> compiledWrapper.call(thisValue, exports, require, module,
                                  filename, dirname);
  }
  hasLoadedAnyUserCJSModule <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span>;
  <span style="color:#ff79c6">if</span> (requireDepth <span style="color:#ff79c6">===</span> <span style="color:#bd93f9">0</span>) statCache <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">null</span>;
  <span style="color:#ff79c6">return</span> result;
};
</code></pre></div><p>首先会调用<code>wrapSafe</code>方法给源代码包装，传入<code>6</code>个参数<code>exports, require, mudole, __filename, __dirname</code>形成一个新函数，如果已经包装过，就直接调用<code>vm.runInThisContext</code>运行这个函数，否则就调用内建模块<code>contextify</code>里的<code>compileFunction</code>函数编译，最终返回一个可执行的函数体。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6272a4">// lib\internal\modules\cjs\loader.js
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">let</span> wrap <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span>(script) {
  <span style="color:#ff79c6">return</span> Module.wrapper[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">+</span> script <span style="color:#ff79c6">+</span> Module.wrapper[<span style="color:#bd93f9">1</span>];
};

<span style="color:#ff79c6">const</span> wrapper <span style="color:#ff79c6">=</span> [
  <span style="color:#f1fa8c">&#39;(function (exports, require, module, __filename, __dirname) { &#39;</span>,
  <span style="color:#f1fa8c">&#39;\n});&#39;</span>
];

<span style="color:#8be9fd;font-style:italic">function</span> wrapSafe(filename, content, cjsModuleInstance) {
<span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">try</span> {
    compiled <span style="color:#ff79c6">=</span> compileFunction(
      content,
      filename,
      <span style="color:#bd93f9">0</span>,
      <span style="color:#bd93f9">0</span>,
      <span style="color:#ff79c6">undefined</span>,
      <span style="color:#ff79c6">false</span>,
      <span style="color:#ff79c6">undefined</span>,
      [],
      [
        <span style="color:#f1fa8c">&#39;exports&#39;</span>,
        <span style="color:#f1fa8c">&#39;require&#39;</span>,
        <span style="color:#f1fa8c">&#39;module&#39;</span>,
        <span style="color:#f1fa8c">&#39;__filename&#39;</span>,
        <span style="color:#f1fa8c">&#39;__dirname&#39;</span>,
      ]
    );
  } <span style="color:#ff79c6">catch</span> (err) {
    <span style="color:#ff79c6">if</span> (process.mainModule <span style="color:#ff79c6">===</span> cjsModuleInstance)
      enrichCJSError(err);
    <span style="color:#ff79c6">throw</span> err;
  }

  <span style="color:#ff79c6">const</span> { callbackMap } <span style="color:#ff79c6">=</span> internalBinding(<span style="color:#f1fa8c">&#39;module_wrap&#39;</span>);
  callbackMap.set(compiled.cacheKey, {
    importModuleDynamically<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">async</span> (specifier) =&gt; {
      <span style="color:#ff79c6">const</span> loader <span style="color:#ff79c6">=</span> asyncESM.ESMLoader;
      <span style="color:#ff79c6">return</span> loader.<span style="color:#ff79c6">import</span>(specifier, normalizeReferrerURL(filename));
    }
  });

  <span style="color:#ff79c6">return</span> compiled.<span style="color:#8be9fd;font-style:italic">function</span>;
}
</code></pre></div><p>回到刚才的<code>_compile</code>，在包装编译完成之后，会将本体的<code>exports, require, module, filename, dirname</code>作为参数传入刚才编译后的函数，最终返回执行的结果。</p>
<p>这里看一下<code>require</code>方法的具体实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6272a4">// // lib\internal\modules\cjs\loader.js
</span><span style="color:#6272a4"></span>Module.prototype.require <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span>(id) {
  validateString(id, <span style="color:#f1fa8c">&#39;id&#39;</span>);
  <span style="color:#ff79c6">if</span> (id <span style="color:#ff79c6">===</span> <span style="color:#f1fa8c">&#39;&#39;</span>) {
    <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> ERR_INVALID_ARG_VALUE(<span style="color:#f1fa8c">&#39;id&#39;</span>, id,
                                    <span style="color:#f1fa8c">&#39;must be a non-empty string&#39;</span>);
  }
  requireDepth<span style="color:#ff79c6">++</span>;
  <span style="color:#ff79c6">try</span> {
    <span style="color:#ff79c6">return</span> Module._load(id, <span style="color:#ff79c6">this</span>, <span style="color:#6272a4">/* isMain */</span> <span style="color:#ff79c6">false</span>);
  } <span style="color:#ff79c6">finally</span> {
    requireDepth<span style="color:#ff79c6">--</span>;
  }
};
</code></pre></div><p>至此， 环境初始化完成，内建模块，<code>native</code>模块以及自定义模块加载完成，主文件编译完毕，在刚刚初始化的<code>Environment</code>上，启动<code>event loop</code>，以及<code>libuv</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#ff79c6">do</span> {
  uv_run(env<span style="color:#ff79c6">-&gt;</span>event_loop(), UV_RUN_DEFAULT);
  per_process<span style="color:#ff79c6">::</span>v8_platform.DrainVMTasks(isolate_);
  more <span style="color:#ff79c6">=</span> uv_loop_alive(env<span style="color:#ff79c6">-&gt;</span>event_loop());
  <span style="color:#ff79c6">if</span> (more <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>env<span style="color:#ff79c6">-&gt;</span>is_stopping()) <span style="color:#ff79c6">continue</span>;
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>uv_loop_alive(env<span style="color:#ff79c6">-&gt;</span>event_loop())) {
    EmitBeforeExit(env.get());
  }
  more <span style="color:#ff79c6">=</span> uv_loop_alive(env<span style="color:#ff79c6">-&gt;</span>event_loop());
} <span style="color:#ff79c6">while</span> (more <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">true</span> <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>env<span style="color:#ff79c6">-&gt;</span>is_stopping());
</code></pre></div>
    </article>
  </div>

</div>


  </div>
<script type="text/javascript" src="/main.js" defer></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-PROPERTY_ID', 'auto');
	
	ga('send', 'pageview');
}
</script>
</body>

</html>