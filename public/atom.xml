<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">秋屿记</title>
    <subtitle type="html">秋屿的个人博客，记载生活点滴与技术灵感。</subtitle>
    <updated>2020-09-27T15:49:28+08:00</updated>
    <id>https://1aomn.com/</id>
    <link rel="alternate" type="text/html" href="https://1aomn.com/" />
    <link rel="self" type="application/atom+xml" href="https://1aomn.com/atom.xml" />
    <author>
            <name>秋屿</name>
            <uri>https://1aomn.com/</uri>
            
                <email>burningdian@gmail.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.66.0">Hugo</generator>
        <entry>
            <title type="text">Javascript原型链</title>
            <link rel="alternate" type="text/html" href="https://1aomn.com/skills/%E5%8E%9F%E5%9E%8B%E9%93%BE/" />
            <id>https://1aomn.com/skills/%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
            <updated>2020-09-25T16:37:54+08:00</updated>
            <published>2020-09-18T00:05:05+08:00</published>
            <author>
                    <name>秋屿</name>
                    <uri>https://1aomn.com</uri>
                    <email>burningdian@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[每个对象都有__proto__属性标识自己继承的原型。 函数被创建时，JS会为这个函数……]]></summary>
            
                <content type="html"><![CDATA[<p>每个对象都有<code>__proto__</code>属性标识自己继承的原型。</p>
<p>函数被创建时，<code>JS</code>会为这个函数添加<code>prototype</code>属性，即该函数可以被当作构造函数使用，值是是一个对象，该对象有一个名为<code>constructor</code>的成员函数，值为该函数本身。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="sb">`Jack`</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Person</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span><span class="p">)</span> <span class="c1">// true
</span></code></pre></td></tr></table>
</div>
</div><p>通过<code>new</code>调用函数(当作构造函数)来构造对象时，会创建该函数的实例化对象，新对象的<code>__proto__</code>指向原函数的<code>prototype</code>属性来实现继承。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="c1">// true
</span></code></pre></td></tr></table>
</div>
</div><p>函数也是一个对象，函数对象由<code>Function</code>构造，其<code>__proto__</code>指向<code>Function.prototype</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">Person</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true
</span></code></pre></td></tr></table>
</div>
</div><p>通过<code>new Object()</code>和<code>{}</code>创建的对象，<code>__proto__</code>属性都指向<code>Object.prototype</code>，因为<code>Object</code>就是他们的构造函数，这与上面的行为是相一致的。</p>
<p>上面提到的，既然<code>Person.prototype</code>的值是一个对象，那么该对象也是有原型的，我们发现它指向<code>Object.prototype</code>，至此达到了该原型链的顶端。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="c1">// null
</span></code></pre></td></tr></table>
</div>
</div><p>但深究下去会发现，既然<code>Object</code>本身是构造函数，其<code>__proto__</code>指向<code>Function.prototype</code>，<code>Function.prototype</code>也是对象，继承了<code>Object.prototype</code>，这就产生了&quot;你中有我，我中有你&quot;的奇怪问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true
</span><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true
</span><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">// true
</span></code></pre></td></tr></table>
</div>
</div><p>在<code>ECMA</code>规范<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4">15.3.4</a>中：</p>
<blockquote>
<p>object (its [[Class]] is <code>&quot;Function&quot;</code>) that, when invoked, accepts any arguments and returns <strong>undefined</strong>.</p>
<p>The value of the [[Prototype]] internal property of the Function prototype object is the standard built-in Object prototype object (<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.2.4">15.2.4</a>). The initial value of the [[Extensible]] internal property of the Function prototype object is <strong>true</strong>.</p>
<p>The Function prototype object does not have a <code>valueOf</code> property of its own; however, it inherits the <code>valueOf</code> property from the Object prototype Object.</p>
<p>The <code>length</code> property of the Function prototype object is <strong>0</strong>.</p>
</blockquote>
<p>所以说普通函数都是<code>Function</code>的实例，他们的<code>__proto__</code>都指向<code>Function.prototype</code>。</p>
<p>而根据规范，<code>Function.prototype</code>本身是一个函数对象，它继承自<code>Object.prototype</code>。</p>
<p>在<code>ECMA</code>规范<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.2.4">15.2.4</a>中：</p>
<blockquote>
<p>The value of the [[Prototype]] internal property of the Object prototype object is <strong>null</strong>, the value of the [[Class]] internal property is <code>&quot;Object&quot;</code>, and the initial value of the [[Extensible]] internal property is <strong>true</strong>.</p>
</blockquote>
<p>总结如下：</p>
<p><code>Object.prototype</code>是最顶级的原型，它的<code>__proto__</code>为<code>null</code>。</p>
<p><code>Function.prototype</code>继承自<code>Object.prototype</code>。</p>
<p>所有的函数对象继承自<code>Function.prototype</code>。</p>
<p>所有由<code>{}</code>，<code>new Object()</code>产生的对象继承自<code>Object</code>。</p>
<p>由函数对象产生的对象，原型指向其构造函数的<code>prototype</code>属性。</p>
<p>经典老图</p>
<p><img src="https://i.loli.net/2020/09/25/aSvQ6XxiDusJzd7.jpg" alt="jsobj_full.jpg"></p>
]]></content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">StreamerHelper</title>
            <link rel="alternate" type="text/html" href="https://1aomn.com/skills/streamerhelper/" />
            <id>https://1aomn.com/skills/streamerhelper/</id>
            <updated>2020-09-18T19:45:12+08:00</updated>
            <published>2020-09-18T00:05:05+08:00</published>
            <author>
                    <name>秋屿</name>
                    <uri>https://1aomn.com</uri>
                    <email>burningdian@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[Introduction StreamerHelper是一个开源项目，可以实现虎牙、斗鱼、AfreecaTV……]]></summary>
            
                <content type="html"><![CDATA[<p><img src="https://camo.githubusercontent.com/657a163e660f32aae67fce0af8cbdef47251f106/68747470733a2f2f73312e617831782e636f6d2f323032302f30372f32322f55624b4370712e706e67" style="zoom:20%;" /></p>
<h2 id="introduction">Introduction</h2>
<p><code>StreamerHelper</code>是一个开源项目，可以实现虎牙、斗鱼、AfreecaTV等主流直播平台主播开播时自动录像，并适时上传。Github地址：<a href="https://github.com/ZhangMingZhao1/StreamerHelper">https://github.com/ZhangMingZhao1/StreamerHelper</a>。</p>
<p><code>StreamerHelper</code>使用<code>Node.js</code>开发，同时集成了直播录制和视频上传的功能，软件部署后，后台实时批量监测各个平台主播是否在线，并使用<code>FFmpeg</code>录制直播保存为视频文件，停播后投稿到b站。</p>
<h2 id="project-tree">Project Tree</h2>
<pre><code>StreamerHelper
├─ src
│  ├─ app.ts
│  ├─ engine
│  │  ├─ getStreamUrl.ts
│  │  ├─ liveStreamStatus.ts
│  │  ├─ message.ts
│  │  ├─ RoomStatus.ts
│  │  └─ website
│  │     ├─ afreecatv.ts
│  │     ├─ bilibili.ts
│  │     ├─ cc.ts
│  │     ├─ ...
│  ├─ type
│  │  ├─ StreamInfo.ts
│  │  └─ VideoPart.ts
│  ├─ uploader
│  │  ├─ caller.ts
│  │  ├─ example.js
│  │  ├─ index.js
│  │  └─ uploadStatus.ts
│  └─ util
│     ├─ crypt.js
│     └─ utils.ts
└─ templates
   └─ info.json
</code></pre><p><code>./src/</code>目录下存放项目源码，<code>src/app.ts</code>为程序入口文件，并且管理下载和上传的业务。</p>
<p><code>./src/engine/</code>目录下为直播流获取及下载模块。</p>
<p><code>./src/engine/website/</code>目录下为获取直播流的模块，以插件的方式集成，统一使用<code>axios</code>作为请求库，方便扩展。</p>
<p><code>./src/uploader/</code>目录下为文件上传/投稿模块，部分代码使用<code>js</code>编写，方便直接调用上传。</p>
<p><code>./src/type/</code>目录下定义了一系列接口。</p>
<p><code>./src/util/</code>目录下封装了一些工具方法，如加盐、解析<code>info.json</code>等。</p>
<p><code>./templates/info.json</code>保存用于投稿的信息，所需录制主播信息。</p>
<p>日志文件会自动创建，在<code>./logs/</code>下。</p>
<h2 id="how-does-it-work">How does it work?</h2>
<p>程序启动之后，首先<code>app.ts</code>里有一个大的定时器<code>const timer = setInterval(F, 12000);</code>，每<code>12s</code>遍历一遍<code>info.json</code></p>
<p>里的主播信息，并调用<code>getStreamUrl()</code>检测主播是否在线，如果检测到在线，会实例化一个<code>Recorder</code>，同时将直播流链接传入构造器，启动下载线程，同时，会有一个监听器监听直播流断开事件。</p>
<p><code>Recorder</code>类的代码在<code>message.ts</code>里，实例化后，会调用子进程启动<code>FFmpeg</code>来以原码率、原音视频编码的格式下载传入的直播流（占用极小，实际测试中占用不到CPU的<code>1%</code>）。直播流断开后，触发<code>streamDiscon</code>事件，事件触发后，程序会根据直播流是否为正常断开，来选择是否上传。</p>
<p>项目以异步的方式下载多个直播流，并且由统一的事件触发器处理直播流断开的情况。当用户向进程发送<code>SIGINT</code>信号后，程序会移除监听<code>streamDiscn</code>事件，并等待<code>FFmpeg</code>子进程结束后退出。</p>
<p>下载的录播文件会暂时存放于<code>./download/</code>下，并在上传成功后自动删除。</p>
<h2 id="troubles--solutions">Troubles &amp; Solutions</h2>
<p>在获取直播源后的地址可以用<code>PotPlayer</code>播放器正常播放，但无法使用<code>FFmpeg</code>下载，并且返回了<code>403 Forbidden</code>错误，多次测试后发现，<code>PotPlayer</code>在播放直播流时默认携带了一系列<code>Headers</code>信息，之后在<code>FFmpeg</code>启动参数中加入<code>Headers</code>信息，可以成功下载。</p>
<p>项目经历过一次比较大的结构调整，主要是将下载器包装成一个<code>Recorder</code>类，可以通过实例化来异步地单独下载每一个直播流，并统一由<code>app.ts</code>管理，这么做的好处是解下载模块与上传模块的耦合，降低复杂度。</p>
<p>当需要强制使一个<code>FFmpeg</code>子进程退出时，可以通过向子进程的<code>stdin</code>的可写流写入<code>q</code>来通知<code>FFmpeg</code>主动退出。</p>
<p>上传模块中，为了避免频繁登录触发验证码，使用了长期有效的<code>access_token</code>来避免验证。</p>
<h2 id="未来计划">未来计划</h2>
<ul>
<li><input disabled="" type="checkbox">支持<code>Twitch</code>。</li>
<li><input disabled="" type="checkbox">支持<code>docker</code>部署。</li>
<li><input disabled="" type="checkbox">爬虫定时区间，节省服务器流量...</li>
<li><input disabled="" type="checkbox">重启后同时检测本地是否有上传失败的视频文件，并上传。</li>
</ul>
]]></content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Cookie，Session和token</title>
            <link rel="alternate" type="text/html" href="https://1aomn.com/skills/cookie-session-token/" />
            <id>https://1aomn.com/skills/cookie-session-token/</id>
            <updated>2020-03-24T23:30:00+08:00</updated>
            <published>2020-03-15T17:42:40+08:00</published>
            <author>
                    <name>秋屿</name>
                    <uri>https://1aomn.com</uri>
                    <email>burningdian@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[Cookie 定义 Cookie，中文名「小甜饼」，是一段用来标识用户身份和附加信息而存储在本地客……]]></summary>
            
                <content type="html"><![CDATA[<h2 id="cookie">Cookie</h2>
<h3 id="定义">定义</h3>
<p>Cookie，中文名「小甜饼」，是一段用来标识用户身份和附加信息而存储在本地客户端上的字符串。</p>
<h3 id="特点">特点</h3>
<p>Cookie有以下几个特点</p>
<ul>
<li>大小有限制，一般不超过5kb</li>
<li>cookie 是没有结构的，但可以用格式如 &quot;a1=v1;a2=v2;a3=v3&quot;来存储结构化数据</li>
<li>跨域不共享，即浏览器为每个域名存储一个 cookie，</li>
<li>浏览器每次发送 http 请求，都会将请求域的 cookie 发送给服务端。这里的请求域仅指本次请求的域，比如在本站首页向 网易云音乐 发送 http 请求，则会向 网易云云音乐 发送本地存储的 cookie 。</li>
<li>服务端可以修改 cookie 并返回给浏览器。</li>
<li>浏览器可以在限制条件下修改 cookie 并返回给服务端。</li>
<li>cookie 在指定的域名及根域名下都生效。</li>
</ul>
<h3 id="缺陷">缺陷</h3>
<p>cookie 通常有以下几个缺陷</p>
<ol>
<li>cookie 在 http 请求中是明文传递的，有信息泄露的风险</li>
<li>cookie 的大小有限制(4kb)，不易存储复杂信息</li>
</ol>
<hr>
<h2 id="session">Session</h2>
<p>session 的本意是会话状态，在 http 中的实现是用来跟踪用户的状态。</p>
<p>由于HTTP协议是无状态的，服务端不知道用户上一次做了什么，所以服务端会在用户初始状态的时候创建特定的 session ，用来标识并跟踪这个用户。</p>
<p>就比如购物网站的购物车，我添加了商品，服务端也做了相应的处理，但服务端不知道这个商品添加到哪，也不知道这个购物车是谁了，有了session，客户端就可以通过它来追踪我，然后服务端也就知道这一系列行为是我做的。</p>
<h3 id="原理">原理</h3>
<ol>
<li>服务端在 cookie 中找到对应的seesionid。</li>
<li>根据 sessionid，从服务端对应的 session 中获取数据，然后返回。</li>
<li>如果找不到 sessionid，服务端创建一个新 session，并将 sessionid 添加到 cookie 中，写入响应头。</li>
</ol>
<h3 id="缺点">缺点</h3>
<ol>
<li>session 存在服务端中，扩展性差。</li>
<li>session 存的东西太多，就会占用过多的内存，无形中增添服务器压力。</li>
<li>依赖于浏览器的 cookie ，有跨域问题</li>
<li>受CSRF攻击的风险。</li>
</ol>
<hr>
<h2 id="token">Token</h2>
<h3 id="原理-1">原理</h3>
<ol>
<li>客户端登录，服务端验证用户名和密码之后，对用户名编码，生成 token 返回给客户端。</li>
<li>客户端将 token 储存，并在每次发送请求的时候附上 token。</li>
<li>客户端后续发送请求，服务端对用户名用同样的方式编码，然后和客户端发过来的 token 做对比，以验证用户合法性。</li>
</ol>
<h3 id="特点-1">特点</h3>
<ol>
<li>Token 不依赖于 Cookie ，可以在不支持 Cookie 的平台上使用，也不会有CSFR攻击的风险</li>
<li>Token 在服务端生成和验证</li>
<li>Token 储存在客户端，比如存在 Cookie ， sessionStorage ， localStorage 中。</li>
</ol>
]]></content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Web后端开发路线图</title>
            <link rel="alternate" type="text/html" href="https://1aomn.com/skills/back-end-roadmap/" />
            <id>https://1aomn.com/skills/back-end-roadmap/</id>
            <updated>2020-03-14T00:29:32+08:00</updated>
            <published>2020-03-14T00:22:49+08:00</published>
            <author>
                    <name>秋屿</name>
                    <uri>https://1aomn.com</uri>
                    <email>burningdian@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html"><![CDATA[https://github.com/kamranahmedse/developer-roadmap]]></summary>
            
                <content type="html"><![CDATA[<p><a href="https://github.com/kamranahmedse/developer-roadmap"> https://github.com/kamranahmedse/developer-roadmap </a></p>
<p><img src="https://i.loli.net/2020/03/14/IVQniKDRw9JMBtc.png" alt="image.png"></p>
]]></content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">谈谈对ACM新生集训队的选拔</title>
            <link rel="alternate" type="text/html" href="https://1aomn.com/skills/talk-about-acm-team/" />
            <id>https://1aomn.com/skills/talk-about-acm-team/</id>
            <updated>2020-03-24T18:52:54+08:00</updated>
            <published>2020-03-10T21:58:44+08:00</published>
            <author>
                    <name>秋屿</name>
                    <uri>https://1aomn.com</uri>
                    <email>burningdian@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[接手校ACM集训队和协会之后，我就想过调整协会的结构和新生的选拔方案，但毕竟我没什么……]]></summary>
            
                <content type="html"><![CDATA[<p>接手校ACM集训队和协会之后，我就想过调整协会的结构和新生的选拔方案，但毕竟我没什么经验，其他管理也没有相同的想法，所以没有贸然调整。</p>
<p>我们这届包括前几届，协会都是由集训队+普通会员构成的，所谓的管理层也是由集训队担任，貌似之前还分A组C组M组，不过这个概念在上一届就淡化了。协会会员没有门槛，交30元社费即可入社，而集训队需要进行选拔，表现优异者方可入队。集训队选拔分三批，第一批是协会纳新之后，有三次面向全体新社员的新生赛，最后按三次比赛的成绩进行排名，取前几名选入新生集训队。第二批是来年的5月份左右，有一次面向全校的校级程序设计竞赛，举办单位为院级，规则也较新生赛更为严苛，赛后依照排名选取部分同学进入集训队。第三批是在暑假里，协会会号召有志愿的同学留校集训，持续一个多月，期间有老师授课，并且定期比赛，最后依照做题量和每次的排名再选取几名同学进入集训队。这样在大一下学期之前，最终选取18名左右的同学进入集训队，无特殊情况不再变动。</p>
<p>所以说对一名新生来说，最有机会进入集训队的时间是第一批，其次是第三批，最后是第二批。想被选入第一批，新生需要入社之后开始刷题，紧跟协会的教学计划，最后在新生赛取得好成绩。这样的方式也产生一些问题，比如说新生开学后的事情比较多，同时新生赛安排在周末，必然会有一部分同学因时间冲突而无法参加，其中不乏编程佼佼者。要知道缺席一次新生赛就可能没机会进入集训队。但如果为了避免时间冲突而把三次新生赛缩减为一次，又无法考量新生的综合水平和阶段性学习情况，有失公允，颇难抉择。</p>
<p>前面主要谈了新生选拔的情况，我感觉目前协会在选拔方面最大的问题是新生赛时间安排不合理，以及新生赛排名对选拔结果的影响太大。另一方面，协会考虑到新生的水平，将三次新生赛的题目设置比较简单，没啥选拔性，通过几次新生赛的最终榜单可以看到，新生AC数量的曲线过于陡峭，有大量爆零或者只过一道题的情况出现。新生赛的目的是让高水平同学在激烈的对抗中脱颖而出，而不是让一大批小白仅仅在体验挨打后丧失兴趣，体验生活。要解决这样的问题，我认为以比赛为主的选拔方式并不可行（仅对我弱校的情况）。就拿一个学校的课程考核来说，一个人的最终成绩也不仅仅由学生的最终考试成绩决定，还有平时成绩、课堂表现等多方面的因素，另外普通课程有一个特别的制度，叫“作业”，我觉得这是一个很好的点。选拔初期，新生的主要学习方式是自学，虽有授课安排，但个人认为收效不大。如何把授课和新生的平时练习结合起来？我认为最好的方式是“留作业”，把巩固和学习的时间放到平时，给学生介绍网上的课程，安排适当的习题，然后把授课的主要内容改为答疑和精讲重难点。着重新生的平时训练，实时公布排名，把做题量排名也算入最终排名，刺激新生平时训练的欲望。这样就一并解决了三个问题，新生赛排名权重过大、授课效率低以及新生平时训练缺乏监督。对于新生赛也要做适当的调整，方式也不难想到就是减少新生赛的次数，有了新生平时的训练情况，题目难度的设置也有了标准。这样也解决的新生时间冲突的问题，如果还有冲突那只能说运气不好。</p>
<p>说了这么多，但终究是纸上得来终觉浅啊，没经过实践的考验。这些东西让我来做是没机会了，争取退役之后能跟学弟们谈谈吧，希望未来能招进来更高质量的队员，也希望学校竞赛能搞的越来越好。</p>
]]></content>
            
            
            
            
            
                
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://1aomn.com/tags/%E6%9D%82%E8%B0%88/" term="杂谈" label="杂谈" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">将Hugo博客搭建在服务器上，使用webhook实时构建</title>
            <link rel="alternate" type="text/html" href="https://1aomn.com/skills/builg-a-blog-on-server/" />
            <id>https://1aomn.com/skills/builg-a-blog-on-server/</id>
            <updated>2020-03-10T21:56:13+08:00</updated>
            <published>2020-03-10T21:55:09+08:00</published>
            <author>
                    <name>秋屿</name>
                    <uri>https://1aomn.com</uri>
                    <email>burningdian@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html"><![CDATA[]]></summary>
            
                <content type="html"><![CDATA[]]></content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text">搭建Hugo博客，通过Netlify自动部署</title>
            <link rel="alternate" type="text/html" href="https://1aomn.com/skills/build-a-blog/" />
            <id>https://1aomn.com/skills/build-a-blog/</id>
            <updated>2020-03-22T00:43:22+08:00</updated>
            <published>2020-03-06T22:02:46+08:00</published>
            <author>
                    <name>秋屿</name>
                    <uri>https://1aomn.com</uri>
                    <email>burningdian@gmail.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[本文章基于Windows10，Hugo_extended_0.66.0，博客发布的流……]]></summary>
            
                <content type="html"><![CDATA[<blockquote>
<p>本文章基于Windows10，Hugo_extended_0.66.0，博客发布的流程是本地上传到github，触发hook后，netlify自动发布</p>
</blockquote>
<h2 id="一下载并安装hugo">一、下载并安装Hugo</h2>
<ul>
<li>
<p><a href="https://github.com/gohugoio/hugo/releases">Hugo下载地址</a></p>
<p>本教程选择了<img src="https://i.loli.net/2020/03/07/zT8oSZCOAib1q4J.png" alt="1583507935042.png">安装，该版本增加了对sass的支持 。</p>
<h4 id="第1步安装hugo">第1步：安装Hugo</h4>
<p>下载解压，完成之后，把hugo.exe添加到全局变量<code>Path</code>。<img src="https://i.loli.net/2020/03/07/LPQvA3RNwEGMJhm.png" alt="1583508112162.png">在控制台中验证安装成功。</p>
</li>
<li>
<p>在Github上新建仓库hugo-on-netlify，并在D:\Blog目录下打开Gitbash，输入指令。</p>
<blockquote>
<p>$ git clone  <a href="https://github.com/xxxxx/hugo-on-netlify">https://github.com/xxxxx/hugo-on-netlify</a></p>
<p>$ hugo new site hugo-on-netlify --force</p>
</blockquote>
<p>此时便会在hugo-on-netlify文件夹里生成网站需要的文件，文件结构如下。</p>
<blockquote>
<pre><code>myblog
├── archetypes
│   └── default.md
├── content
├── data
├── layouts
├── static
├── themes
└── config.toml
</code></pre></blockquote>
</li>
</ul>
<h4 id="第2步安装主题meme">第2步：安装主题Meme</h4>
<p>Hugo是没有默认主题的，这里选用主题<a href="https://github.com/reuixiy/hugo-theme-meme">Meme</a>。</p>
<blockquote>
<p>$ git clone  <a href="https://github.com/reuixiy/hugo-theme-meme.git">https://github.com/reuixiy/hugo-theme-meme.git</a> themes/meme</p>
</blockquote>
<p>然后替换 <code>config.toml</code> 为 <a href="https://github.com/reuixiy/hugo-theme-meme/blob/master/config-examples/zh-cn/config.toml">config.toml</a> ，可以在其中进行个性化设置。</p>
<h4 id="第3步测试">第3步：测试</h4>
<p>创建测试页面</p>
<blockquote>
<p>$ hugo new posts/my-first-post.md</p>
<p>$ hugo new about/_index.md</p>
</blockquote>
<p>此时，基本工作已经完成了，使用</p>
<blockquote>
<p>$ hugo server -D</p>
</blockquote>
<p>在浏览器里访问<code>http://localhost:1313/</code>，预览博客效果。</p>
<h2 id="二上传github">二、上传Github</h2>
<p>之前我们已经新建了hugo-on-netlify仓库，下一步把博客上传</p>
<blockquote>
<p>$ git add .  #将所有文件添加到仓库里</p>
<p>$ git commit -m &quot;commit message&quot;</p>
<p>$ git push -u origin master</p>
</blockquote>
<p>以上也是更新文章所需的操作，如果嫌麻烦，可以写一个bat脚本减轻工作量。</p>
<h2 id="三使用netlify发布网站">三、使用Netlify发布网站</h2>
<p>官网<a href="https://www.netlify.com/">Netlify</a>可以直接通过Github登录，非常方便。</p>
<h4 id="第1步配置文件">第1步：配置文件</h4>
<p>首先在网站根目录下添加<code>netlify.toml</code>文件，如官网所示：</p>
<blockquote>
<p>[build]
publish = &quot;public&quot;
command = &quot;hugo --gc --minify&quot;</p>
<p>[context.production.environment]
HUGO_VERSION = &quot;0.66.0&quot;
HUGO_ENV = &quot;production&quot;
HUGO_ENABLEGITINFO = &quot;true&quot;</p>
<p>[context.split1]
command = &quot;hugo --gc --minify --enableGitInfo&quot;</p>
<p>[context.split1.environment]
HUGO_VERSION = &quot;0.66.0&quot;
HUGO_ENV = &quot;production&quot;</p>
<p>[context.deploy-preview]
command = &quot;hugo --gc --minify --buildFuture -b $DEPLOY_PRIME_URL&quot;</p>
<p>[context.deploy-preview.environment]
HUGO_VERSION = &quot;0.66.0&quot;</p>
<p>[context.branch-deploy]
command = &quot;hugo --gc --minify -b $DEPLOY_PRIME_URL&quot;</p>
<p>[context.branch-deploy.environment]
HUGO_VERSION = &quot;0.66.0&quot;</p>
<p>[context.next.environment]
HUGO_ENABLEGITINFO = &quot;true&quot;</p>
</blockquote>
<h4 id="第2步netlify配置">第2步：Netlify配置</h4>
<p>根据官网的指引，连接Github中的blog-on-netlify仓库，然后修改设置。</p>
<p>首先修改<code>Build settings</code>，因为需要Netlify通过hugo构建，故做如下修改</p>
<p><img src="https://i.loli.net/2020/03/07/Cms9vcMBQaoZxfO.png" alt="1583510667070.png"></p>
<p>然后修改</p>
<p><img src="https://i.loli.net/2020/03/07/nEK6tA4o2NzQyGq.png" alt="1583510849748.png"></p>
<p>这里的修改是因为Netlify默认使用的Hugo版本过低，需要手动设置，否则不支持Meme主题。</p>
<h4 id="第3步完成">第3步：完成</h4>
<p>构建完成后，Netlify会自动生成一个二级域名，指向你的博客，至此Hugo博客的搭建就完成了。</p>
<h2 id="四自定义域名">四、自定义域名</h2>
<p>因为之前在腾讯云上搭建过博客，也是在上面注册的.com域名，所以这里以腾讯云的DNS解析操作为例。</p>
<p>操作很简单，首先在Domian management中添加域名<img src="https://i.loli.net/2020/03/07/QN67BfgvWCZuHFE.png" alt="1583511456178.png">然后在腾讯云域名的解析记录里添加两条记录。</p>
<p><img src="https://i.loli.net/2020/03/09/xan3kQCeifIWtvy.png" alt="image.png"></p>
<p>等待10分钟后，就可以通过域名访问自己的网站了。</p>
<p>Netlify推荐使用 SSL/TLS 的域名，白嫖的方法很多，这里就不赘述了。</p>
]]></content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
</feed>
