<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>秋屿</title>
        <link>https://1aomn.com/</link>
        <description>秋屿的个人博客，记载生活点滴与技术灵感。</description>
        <generator>Hugo 0.66.0 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>burningdian@gmail.com (秋屿)</managingEditor>
        
        
            <webMaster>burningdian@gmail.com (秋屿)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
        
        <lastBuildDate>Tue, 24 Mar 2020 23:30:06 +0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss+xml" href="https://1aomn.com/rss.xml" />
        
        
            <item>
                <title>我会写的排序算法总结</title>
                <link>https://1aomn.com/skills/summary-of-sort-algo/</link>
                <guid isPermaLink="true">https://1aomn.com/skills/summary-of-sort-algo/</guid>
                <pubDate>Tue, 17 Mar 2020 01:28:15 +0800</pubDate>
                
                    <author>burningdian@gmail.com (秋屿)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description><![CDATA[<p>C++和Go。</p>
<hr>
]]></description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Cookie，Session和token</title>
                <link>https://1aomn.com/skills/cookie-session-token/</link>
                <guid isPermaLink="true">https://1aomn.com/skills/cookie-session-token/</guid>
                <pubDate>Sun, 15 Mar 2020 17:42:40 +0800</pubDate>
                
                    <author>burningdian@gmail.com (秋屿)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description><![CDATA[<h2 id="cookie">Cookie</h2>
<h3 id="定义">定义</h3>
<p>Cookie，中文名「小甜饼」，是一段用来标识用户身份和附加信息而存储在本地客户端上的字符串。</p>
<h3 id="特点">特点</h3>
<p>Cookie有以下几个特点</p>
<ul>
<li>大小有限制，一般不超过5kb</li>
<li>cookie 是没有结构的，但可以用格式如 &quot;a1=v1;a2=v2;a3=v3&quot;来存储结构化数据</li>
<li>跨域不共享，即浏览器为每个域名存储一个 cookie，</li>
<li>浏览器每次发送 http 请求，都会将请求域的 cookie 发送给服务端。这里的请求域仅指本次请求的域，比如在本站首页向 网易云音乐 发送 http 请求，则会向 网易云云音乐 发送本地存储的 cookie 。</li>
<li>服务端可以修改 cookie 并返回给浏览器。</li>
<li>浏览器可以在限制条件下修改 cookie 并返回给服务端。</li>
<li>cookie 在指定的域名及根域名下都生效。</li>
</ul>
<h3 id="缺陷">缺陷</h3>
<p>cookie 通常有以下几个缺陷</p>
<ol>
<li>cookie 在 http 请求中是明文传递的，有信息泄露的风险</li>
<li>cookie 的大小有限制(4kb)，不易存储复杂信息</li>
</ol>
<hr>
<h2 id="session">Session</h2>
<p>session 的本意是会话状态，在 http 中的实现是用来跟踪用户的状态。</p>
<p>由于HTTP协议是无状态的，服务端不知道用户上一次做了什么，所以服务端会在用户初始状态的时候创建特定的 session ，用来标识并跟踪这个用户。</p>
<p>就比如购物网站的购物车，我添加了商品，服务端也做了相应的处理，但服务端不知道这个商品添加到哪，也不知道这个购物车是谁了，有了session，客户端就可以通过它来追踪我，然后服务端也就知道这一系列行为是我做的。</p>
<h3 id="原理">原理</h3>
<ol>
<li>服务端在 cookie 中找到对应的seesionid。</li>
<li>根据 sessionid，从服务端对应的 session 中获取数据，然后返回。</li>
<li>如果找不到 sessionid，服务端创建一个新 session，并将 sessionid 添加到 cookie 中，写入响应头。</li>
</ol>
<h3 id="缺点">缺点</h3>
<ol>
<li>session 存在服务端中，扩展性差。</li>
<li>session 存的东西太多，就会占用过多的内存，无形中增添服务器压力。</li>
<li>依赖于浏览器的 cookie ，有跨域问题</li>
<li>受CSRF攻击的风险。</li>
</ol>
<hr>
<h2 id="token">Token</h2>
<h3 id="原理-1">原理</h3>
<ol>
<li>客户端登录，服务端验证用户名和密码之后，对用户名编码，生成 token 返回给客户端。</li>
<li>客户端将 token 储存，并在每次发送请求的时候附上 token。</li>
<li>客户端后续发送请求，服务端对用户名用同样的方式编码，然后和客户端发过来的 token 做对比，以验证用户合法性。</li>
</ol>
<h3 id="特点-1">特点</h3>
<ol>
<li>Token 不依赖于 Cookie ，可以在不支持 Cookie 的平台上使用，也不会有CSFR攻击的风险</li>
<li>Token 在服务端生成和验证</li>
<li>Token 储存在客户端，比如存在 Cookie ， sessionStorage ， localStorage 中。</li>
</ol>
]]></description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Web后端开发路线图</title>
                <link>https://1aomn.com/skills/back-end-roadmap/</link>
                <guid isPermaLink="true">https://1aomn.com/skills/back-end-roadmap/</guid>
                <pubDate>Sat, 14 Mar 2020 00:22:49 +0800</pubDate>
                
                    <author>burningdian@gmail.com (秋屿)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description><![CDATA[<p><a href="https://github.com/kamranahmedse/developer-roadmap"> https://github.com/kamranahmedse/developer-roadmap </a></p>
<p><img src="https://i.loli.net/2020/03/14/IVQniKDRw9JMBtc.png" alt="image.png"></p>
]]></description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>谈谈对ACM新生集训队的选拔</title>
                <link>https://1aomn.com/skills/talk-about-acm-team/</link>
                <guid isPermaLink="true">https://1aomn.com/skills/talk-about-acm-team/</guid>
                <pubDate>Tue, 10 Mar 2020 21:58:44 +0800</pubDate>
                
                    <author>burningdian@gmail.com (秋屿)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description><![CDATA[<p>接手校ACM集训队和协会之后，我就想过调整协会的结构和新生的选拔方案，但毕竟我没什么经验，其他管理也没有相同的想法，所以没有贸然调整。</p>
<p>我们这届包括前几届，协会都是由集训队+普通会员构成的，所谓的管理层也是由集训队担任，貌似之前还分A组C组M组，不过这个概念在上一届就淡化了。协会会员没有门槛，交30元社费即可入社，而集训队需要进行选拔，表现优异者方可入队。集训队选拔分三批，第一批是协会纳新之后，有三次面向全体新社员的新生赛，最后按三次比赛的成绩进行排名，取前几名选入新生集训队。第二批是来年的5月份左右，有一次面向全校的校级程序设计竞赛，举办单位为院级，规则也较新生赛更为严苛，赛后依照排名选取部分同学进入集训队。第三批是在暑假里，协会会号召有志愿的同学留校集训，持续一个多月，期间有老师授课，并且定期比赛，最后依照做题量和每次的排名再选取几名同学进入集训队。这样在大一下学期之前，最终选取18名左右的同学进入集训队，无特殊情况不再变动。</p>
<p>所以说对一名新生来说，最有机会进入集训队的时间是第一批，其次是第三批，最后是第二批。想被选入第一批，新生需要入社之后开始刷题，紧跟协会的教学计划，最后在新生赛取得好成绩。这样的方式也产生一些问题，比如说新生开学后的事情比较多，同时新生赛安排在周末，必然会有一部分同学因时间冲突而无法参加，其中不乏编程佼佼者。要知道缺席一次新生赛就可能没机会进入集训队。但如果为了避免时间冲突而把三次新生赛缩减为一次，又无法考量新生的综合水平和阶段性学习情况，有失公允，颇难抉择。</p>
<p>前面主要谈了新生选拔的情况，我感觉目前协会在选拔方面最大的问题是新生赛时间安排不合理，以及新生赛排名对选拔结果的影响太大。另一方面，协会考虑到新生的水平，将三次新生赛的题目设置比较简单，没啥选拔性，通过几次新生赛的最终榜单可以看到，新生AC数量的曲线过于陡峭，有大量爆零或者只过一道题的情况出现。新生赛的目的是让高水平同学在激烈的对抗中脱颖而出，而不是让一大批小白仅仅在体验挨打后丧失兴趣，体验生活。要解决这样的问题，我认为以比赛为主的选拔方式并不可行（仅对我弱校的情况）。就拿一个学校的课程考核来说，一个人的最终成绩也不仅仅由学生的最终考试成绩决定，还有平时成绩、课堂表现等多方面的因素，另外普通课程有一个特别的制度，叫“作业”，我觉得这是一个很好的点。选拔初期，新生的主要学习方式是自学，虽有授课安排，但个人认为收效不大。如何把授课和新生的平时练习结合起来？我认为最好的方式是“留作业”，把巩固和学习的时间放到平时，给学生介绍网上的课程，安排适当的习题，然后把授课的主要内容改为答疑和精讲重难点。着重新生的平时训练，实时公布排名，把做题量排名也算入最终排名，刺激新生平时训练的欲望。这样就一并解决了三个问题，新生赛排名权重过大、授课效率低以及新生平时训练缺乏监督。对于新生赛也要做适当的调整，方式也不难想到就是减少新生赛的次数，有了新生平时的训练情况，题目难度的设置也有了标准。这样也解决的新生时间冲突的问题，如果还有冲突那只能说运气不好。</p>
<p>说了这么多，但终究是纸上得来终觉浅啊，没经过实践的考验。这些东西让我来做是没机会了，争取退役之后能跟学弟们谈谈吧，希望未来能招进来更高质量的队员，也希望学校竞赛能搞的越来越好。</p>
]]></description>
                
                
                
                
                
                    
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://1aomn.com/tags/%E6%9D%82%E8%B0%88/">杂谈</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>将Hugo博客搭建在服务器上，使用webhook实时构建</title>
                <link>https://1aomn.com/skills/builg-a-blog-on-server/</link>
                <guid isPermaLink="true">https://1aomn.com/skills/builg-a-blog-on-server/</guid>
                <pubDate>Tue, 10 Mar 2020 21:55:09 +0800</pubDate>
                
                    <author>burningdian@gmail.com (秋屿)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description><![CDATA[]]></description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Golang入门总结</title>
                <link>https://1aomn.com/skills/golang-start/</link>
                <guid isPermaLink="true">https://1aomn.com/skills/golang-start/</guid>
                <pubDate>Sun, 08 Mar 2020 01:35:09 +0800</pubDate>
                
                    <author>burningdian@gmail.com (秋屿)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description><![CDATA[<h2 id="输入输出">输入输出</h2>
<p>Golang 有类似C语言的格式化输入输出，常用占位符如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="o">%</span><span class="nx">v</span>		<span class="nx">对应值的默认格式</span>
<span class="o">%</span><span class="nx">T</span>		<span class="nx">对应值的类别</span>
</code></pre></td></tr></table>
</div>
</div><p>整数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="o">%</span><span class="nx">d</span>		<span class="nx">十进制表示</span>
<span class="o">%</span><span class="nx">b</span>		<span class="nx">二进制表示</span>
<span class="o">%</span><span class="nx">o</span>		<span class="nx">八进制表示</span>
<span class="o">%</span><span class="nx">x</span>		<span class="nx">十六进制表示</span>
</code></pre></td></tr></table>
</div>
</div><p>Golang没有无符号整型的占位符</p>
<p>浮点数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="o">%</span><span class="nx">f</span>		<span class="nx">一般小数</span>
<span class="o">%</span><span class="nx">e</span>		<span class="nx">科学计数法</span>
</code></pre></td></tr></table>
</div>
</div><p>字符串：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="o">%</span><span class="nx">s</span>		<span class="nx">字符串</span>
</code></pre></td></tr></table>
</div>
</div><p>指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="o">%</span><span class="nx">p</span>		<span class="nx">十六进制表示</span><span class="err">，</span><span class="nx">前缀0x</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="print">Print</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Print</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>使用其操作数的默认格式进行格式化并写入到标准输出。 当两个连续的操作数均不为字符串时，它们之间就会添加空格。</p>
<h4 id="printf">Printf</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>根据格式说明符写入到标准输出。</p>
<h4 id="println">Println</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>根据默认格式格式化后写入到标准输出，格式之间添加空格，最后添加换行符。</p>
<h4 id="scan">Scan</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Scan</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Scan 扫描从标准输入中读取的文本，并将连续由空格分隔的值存储为连续的实参。 换行符计为空格。</p>
<h4 id="scanf">Scanf</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Scanf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>扫描从标准输入中读取的文本， 并将连续由空格分隔的值存储为连续的实参 。</p>
<h4 id="scanln">Scanln</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Scanln</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>类似Scan，但它在换行符处停止扫描，且最后的条目之后必须为换行符或 EOF。</p>
<h4 id="sprint">Sprint</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Sprint</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><p>使用其操作数的默认格式进行格式化并返回其结果字符串。 当两个连续的操作数均不为字符串时，它们之间就会添加空格。</p>
<h4 id="sprintf">Sprintf</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Sprintf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span>
</code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="变量">变量</h2>
<p>Golang中的变量一经定义，必须使用</p>
<p>全局定义的变量，如果首字母大写则对其他包可以访问。</p>
<p>变量类型：</p>
<h4 id="整数">整数</h4>
<pre><code>(u)int  (u)int8  (u)int16  (u)int32  (u)int64
</code></pre><h4 id="浮点数">浮点数</h4>
<pre><code>float32  float64
</code></pre><h4 id="字符字符串">字符/字符串</h4>
<pre><code>string	byte  rune(每个字符占一个长度)
</code></pre><h4 id="布尔型">布尔型</h4>
<pre><code>bool
</code></pre><h4 id="常量">常量</h4>
<pre><code>const a float32 = 3.14
const (
		A = 1
		B = 2)
</code></pre><p>常量的值必须是编译期间确定的数字、字符串、布尔值</p>
<h4 id="函数变量">函数变量</h4>
<pre><code>func test(a int)int{
	return a*a
}
var f = test
var f2 = func(a int)int{
	return a*a
}//匿名函数
f(3)//9
</code></pre><h4 id="变量声明">变量声明</h4>
<pre><code>var v type
v := value
</code></pre><hr>
<h2 id="字符串">字符串</h2>
<p>一个字符串是一个不可改变的字符序列。 字符串的任何操作会产生一个新字符串并返回。</p>
<p>字符串可以用反引号代替双引号，表示字符串的原生格式。</p>
<pre><code>var s string = `
Line: 1
Line: 2  //这是第二行`

Line: 1
Line: 2  //这是第二行 
</code></pre><p>字符串的底层是一个<code>byte</code>的数组，也可以进行切片操作</p>
<pre><code>s1 := &quot;abcd&quot;
s2 := s1[1:3]//bc
</code></pre><p>可以通过<code>string</code>和<code>rune</code>的类型转换，达到改变字符串的目的</p>
<pre><code>s1 := &quot;abcd&quot;
s2 := []rune(s1)
s2[1]='B'
s1 = string(s2)
fmt.Println(s1)//&quot;aBcd&quot;
</code></pre><p>为何不用<code>[]byte</code>？</p>
<p>考虑到中文字符</p>
<h4 id="常用函数">常用函数</h4>
<pre><code>strings包下
Index(str,s string) int//查询字符串第一次出现的位置
LastIndex(str,s string) int//查询字符串最后一次出现的位置
Replace(str,old string,new string,n) string//替换子串old为new，次数为n,-1代表无限次
Count(str,substr string) int//查询出现次数
Repeat(s string,count int) string//生成新字符串，值为s重复count次
TrimSpace(str string) string//去除首位空格
Trim(str string,cutset string) string//去除首位字符串cutstr
Split(str string,sep string)//以sep分隔开，返回一个string切片
Join(str string,sep string) string//将切片str以sep连接，返回新字符串
</code></pre><p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换。</p>
<pre><code>strconv包下
x, err := strconv.Atoi(&quot;123&quot;)
y, err := strconv.ParseInt(&quot;123&quot;,10,64) //10进制，64位。默认返回int64类型
</code></pre><h2 id="数组">数组</h2>
<p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。</p>
<p>数组是固定的，不同长度的数组是不同类型，数组的长度必须是常量表达式，在编译时确定。</p>
<p>数组定义时，默认被初始化元素类型对应的零值。</p>
<p>数组的长度是...时，表示数组长度根据初始化值的个数来计算。</p>
<pre><code>b := [3]int{1,2,3}
var b [3]int = [...]int{1,2,3}
b := [...]int{1:2,3:4}//指定索引赋值
</code></pre><p>数组是值类型，作为函数的参数时为值传递</p>
<p>两个数组的长度和类型均相同时可以被比较，否则会编译错误。</p>
<h2 id="切片">切片</h2>
<p>切片(slice)是在数组之上的抽象数据类型，数组不够灵活，切片应运而生。</p>
<pre><code>a := []int{1,2,3}
</code></pre><h4 id="创建切片">创建切片</h4>
<p>基于数组创建</p>
<pre><code>a := [5]{1,2,3,4,5}
b := a[1:3]//slice
b == &amp;a[1]
</code></pre><p>新切片和原数组共享内存，当切片被扩容时，会开辟新的地址，并将原切片复制过去。</p>
<p>也可以使用<code>make</code>创建</p>
<pre><code>func make([]T, len, cap) []T
</code></pre><p>T表示被创建的切片的元素类型， 函数 <code>make</code> 接受一个类型、一个长度和一个可选的容量参数。 调用 <code>make</code> 时，内部会分配一个数组，然后返回数组对应的切片。</p>
<pre><code>var s []byte
s = make([]byte,5,5)
</code></pre><p>容量参数被忽略时，默认为<code>len</code></p>
<pre><code>s := make([]byte,5)
len(s) == 5
cap(s) == 5
</code></pre><h4 id="切片的原理">切片的原理</h4>
<p>切片本身不是数组，他表面上是数组片段。它包含了指向数组的指针，片段长度，最大容量(指向的数组长度)。</p>
<p><img src="https://i.loli.net/2020/03/13/GlBdFOgMH8VpsWm.png" alt="image.png"></p>
<p>使用make([]byte,5)创建切片后，s结构如下</p>
<p><img src="https://i.loli.net/2020/03/13/59Gvb1kq82aBZf7.png" alt="image.png"></p>
<h4 id="append-copy">append, copy</h4>
<p>切片可以通过<code>append</code>函数扩容</p>
<pre><code>func append(s []T, x ...T) []T
</code></pre><p><code>append</code>函数将x添加到切片s的尾部，并在必要时增加容量。</p>
<pre><code>s := []int{1,2,3}
q := s
//q==s
append(q,4,5)
//q!=s
</code></pre><p>对达到最大容量的切片扩容时，会创建一个新的更大的切片并将原数据复制过去。</p>
<p>切片可以通过<code>copy()</code>函数拷贝</p>
<pre><code>a := []int{1,2,3,4,5}
b := make([]int,10)
copy(b,a)
</code></pre><p><code>copy</code>为值拷贝，改变原切片的值不会影响新切片</p>
<p>如果<code>copy</code>的目标切片的cap比原切片的len小时，忽略后面的值</p>
<pre><code>a := []int{1,2,3,4,5}
b := make([]int,2)
copy(b,a)
fmt.Println(b)
//[1 2]
</code></pre><h2 id="函数">函数</h2>
<p>在Golang中，函数是一等公民。</p>
<h4 id="函数的声明">函数的声明</h4>
<pre><code>func func_name(args...) (return-type){
	body
}
</code></pre><h4 id="参数传递">参数传递</h4>
<p>Golang中，无论是值传递还是引用传递，传递给函数的都是变量的副本，值传递为值的拷贝，引用传递为地址的拷贝。</p>
<p>其中<code>map , slice, chan, 指针, interface</code>默认为引用传递。</p>
<h4 id="可变参数">可变参数</h4>
<p>args可以是不定长的</p>
<pre><code>func add(arg...)int{
	...
}
</code></pre><p>传入参数保存在<code>arg</code>中，arg是一个slice。使用<code>arg[i]</code>访问参数，<code>len(arg)</code>获取参数个数。</p>
<h4 id="defer">defer</h4>
<p><code>defer</code>关键字表示的语句，会在函数返回时执行，<code>defer</code>语句中的变量，在<code>defer</code>声明时就决定了</p>
<p>多个<code>defer</code>以栈的顺序执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f</span><span class="p">(){</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span>
	<span class="nx">refer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="nx">i</span><span class="o">++</span>
	<span class="nx">refer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
<span class="c1">//4
</span><span class="c1">//3
</span></code></pre></td></tr></table>
</div>
</div><h4 id="init">init</h4>
<p><code>init()</code>函数在包初始化时执行，在<code>main</code>函数之前完成。</p>
<hr>
<h2 id="常用内置函数">常用内置函数</h2>
<h4 id="new">new</h4>
<p><code>new</code>给变量分配内存，并置为零值，然后返回指针</p>
<pre><code>i := new(int)
//(*i)==0
s := new(string)
//(*s)==&quot;&quot;
</code></pre><h4 id="make">make</h4>
<p><code>make</code>用于给引用类型分配内存并初始化，如<code>slice, map, channel</code>。</p>
<pre><code>v := make([]int,10,50)//len=10, cap=50
c := make(chan int,10)
</code></pre><hr>
<h2 id="结构体">结构体</h2>
<p>Golang 中没有类的概念，但结构体可以看作是其他语言的类。</p>
<h3 id="声明">声明</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">标识符</span> <span class="kd">struct</span><span class="p">{</span>
	<span class="nx">field1</span> <span class="kd">type</span>
	<span class="nx">field2</span> <span class="kd">type</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="定义">定义</h3>
<p>结构体的定义有三种形式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">A</span> <span class="nx">People</span>
<span class="kd">var</span> <span class="nx">A</span> <span class="o">*</span><span class="nx">People</span>  <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">People</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">A</span> <span class="o">*</span><span class="nx">People</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">People</span><span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="访问">访问</h3>
<p>和C语言一样，使用<code>.</code></p>
<pre><code>type People struct{
	Name string
	age int
}

fmt.println(A.Name)//指针形式也可以通过此方式访问
fmt.println((*A).Name)
</code></pre><h3 id="初始化">初始化</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">A</span> <span class="o">:=</span> <span class="nx">People</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span><span class="s">&#34;Youmu&#34;</span><span class="p">,}</span>
</code></pre></td></tr></table>
</div>
</div><p>Golang没有构造函数，可以通过工厂模式实现结构体的实例化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewPeople</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span><span class="nx">age</span> <span class="nx">ing</span><span class="p">)(</span><span class="o">*</span><span class="nx">People</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">People</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span>
		<span class="nx">Age</span><span class="p">:</span>  <span class="nx">age</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="nx">people</span> <span class="o">:=</span> <span class="nf">NewPeople</span><span class="p">(</span><span class="s">&#34;Youmu&#34;</span><span class="p">,</span><span class="mi">14</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="tag">tag</h3>
<p>结构体的每个字段可以写上一个<code>tag</code>，这个<code>tag</code>可以在运行时通过<code>reflection</code>包读取。<code>tag</code>通常用在<code>json</code>的转换中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">People</span> <span class="kd">struct</span><span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;user_name&#34;`</span>
	<span class="nx">age</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="nx">A</span> <span class="o">:=</span> <span class="nf">People</span><span class="p">(</span><span class="nx">Name</span><span class="p">:</span><span class="s">&#34;Youmu&#34;</span><span class="p">,</span><span class="nx">age</span><span class="p">:</span><span class="mi">14</span><span class="p">)</span>
<span class="nx">d</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">A</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">A</span><span class="p">))</span>
<span class="c1">//{&#34;user_name&#34;:&#34;Youmu&#34;}
</span><span class="c1">//age为首字母小写，外部包&#34;encoding/json&#34;对其不可访问。
</span></code></pre></td></tr></table>
</div>
</div><h3 id="匿名字段-和-继承">匿名字段 和 继承</h3>
<p>匿名字段通常搭配继承使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">People</span> <span class="kd">struct</span><span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">age</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Student</span> <span class="kd">struct</span><span class="p">{</span>
	<span class="nx">People</span>	<span class="c1">//Studeng继承People的所有属性，方法
</span><span class="c1"></span>	<span class="nx">score</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="nx">stu</span> <span class="o">:=</span> <span class="nx">Student</span><span class="p">{</span>
	<span class="nx">People</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;Marisa&#34;</span>
		<span class="nx">age</span><span class="p">:</span>  <span class="mi">15</span>
	<span class="p">},</span>
	<span class="nx">score</span><span class="p">:</span>	<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stu</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span><span class="nx">stu</span><span class="p">.</span><span class="nx">People</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span><span class="nx">stu</span><span class="p">.</span><span class="nx">age</span><span class="p">,</span><span class="nx">stu</span><span class="p">.</span><span class="nx">score</span><span class="p">)</span>
<span class="c1">//可以隐式地引用所继承结构体的变量，但是如果结构体中有重名变量，需要显示引用
</span></code></pre></td></tr></table>
</div>
</div><h3 id="方法">方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">People</span> <span class="kd">struct</span><span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">age</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="nx">People</span><span class="p">)</span><span class="nf">eat</span><span class="p">()(</span><span class="kt">string</span><span class="p">){</span><span class="c1">//该方法属于结构体People，this是执行方法执行者的副本
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">this</span><span class="p">.</span><span class="nx">Name</span> <span class="o">+</span> <span class="s">&#34; eat something&#34;</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">People</span><span class="p">)</span><span class="nf">setAge</span><span class="p">(</span><span class="nx">age</span> <span class="kt">int</span><span class="p">){</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">Age</span> <span class="p">=</span> <span class="nx">age</span>
<span class="p">}</span>
<span class="nx">A</span> <span class="o">:=</span> <span class="nf">People</span><span class="p">(</span><span class="nx">Name</span><span class="p">:</span><span class="s">&#34;Yuyuko&#34;</span><span class="p">,</span><span class="nx">age</span><span class="p">:</span><span class="mi">1000</span><span class="p">)</span>
<span class="nx">A</span><span class="p">.</span><span class="nf">setAge</span><span class="p">(</span><span class="mi">1001</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nf">eat</span><span class="p">(),</span><span class="nx">A</span><span class="p">.</span><span class="nx">Age</span><span class="p">)</span>
<span class="c1">//Yuyuko eat something 1001
</span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="接口">接口</h2>
<p>接口定义了一组方法，这些方法不需要被实现，同时接口内不能定义任何变量。</p>
<p>显然，一个结构体可以实现多个接口。</p>
<h3 id="定义-1">定义</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">example</span> <span class="kd">interface</span><span class="p">{</span>
	<span class="nf">Method1</span><span class="p">(</span><span class="nx">参数列表</span><span class="p">)</span> <span class="p">(</span><span class="nx">返回值列表</span><span class="p">)</span>
	<span class="nf">Method2</span><span class="p">(</span><span class="nx">参数列表</span><span class="p">)</span> <span class="p">(</span><span class="nx">返回值列表</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="实现">实现</h3>
<p>一个结构体实现了接口中的所有方法，那么这个结构体就实现了这个接口，不需要显式的实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Car</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">getName</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">run</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">BMW</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">car</span> <span class="nx">BMW</span><span class="p">)</span><span class="nf">getName</span><span class="p">()</span><span class="kt">string</span>  <span class="p">{</span>
	<span class="k">return</span> <span class="nx">car</span><span class="p">.</span><span class="nx">Name</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">car</span> <span class="nx">BMW</span><span class="p">)</span><span class="nf">run</span><span class="p">()</span>  <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">car</span><span class="p">.</span><span class="nf">getName</span><span class="p">(),</span><span class="s">&#34;is running&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">car1</span> <span class="nx">BMW</span> <span class="p">=</span> <span class="nx">BMW</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span><span class="s">&#34;MyCar&#34;</span><span class="p">}</span>
	<span class="nx">car1</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span>
	
	<span class="kd">var</span> <span class="nx">car2</span> <span class="nx">Car</span>
	<span class="nx">car2</span> <span class="p">=</span> <span class="nx">car1</span>
	<span class="nx">car2</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>实现了接口的结构体实例可以赋值给接口变量，这点类似于Java的上转型对象。</p>
<h3 id="嵌套">嵌套</h3>
<p>一个接口可以嵌套在另一个接口。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">A</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">A_func1</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">B</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">A</span>
	<span class="nf">B_func1</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="类型断言">类型断言</h3>
<p>类型断言可以得到一个接口变量隐含的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码表示<code>i</code>是一个接口变量，<code>T</code>是<code>i</code>所隐含的值的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="mi">1</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">i</span> <span class="kd">interface</span><span class="p">{}</span><span class="c1">//任何类型都实现了空接口，所以任何类型都可以赋值给空接口。
</span><span class="c1"></span>	<span class="nx">i</span> <span class="p">=</span> <span class="mi">3</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nx">i</span><span class="p">.(</span><span class="kt">int</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果<code>i</code>不包含类型<code>T</code>，则会抛出<code>panic</code>异常，用<code>ok</code>来判断是否转换成功。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span><span class="p">,</span><span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>使用类型断言搭配<code>switch</code>实现判断参数的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">judgeType</span><span class="p">(</span><span class="nx">items</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">item</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d is int\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
		<span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s is string\n&#34;</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;other type&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="反射">反射</h3>
<p>Golang的反射机制，允许程序操作任意类型的变量。</p>
<p>常见的用法是将一个未知的变量存储在空接口<code>interface{}</code>中，作为参数传递给<code>reflect.ValueOf()</code>，然后该函数对空接口进行解包，将隐含的数据封装到<code>value</code>类型中并返回。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">fakeInt</span> <span class="kt">float32</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="nx">fakeInt</span> <span class="p">=</span> <span class="mf">3.3</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="c1">//变量a本身就实现了Interface{}，不用显示转换
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Float</span><span class="p">())</span><span class="c1">//3.299999952316284
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span><span class="c1">//main.fakeInt
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span><span class="c1">//float32
</span><span class="c1"></span>
	<span class="nx">vi</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Interface</span><span class="p">()</span><span class="c1">//转回Interface{}
</span><span class="c1"></span>	<span class="nx">vif</span> <span class="o">:=</span> <span class="nx">vi</span><span class="p">.(</span><span class="nx">fakeInt</span><span class="p">)</span><span class="c1">//转回fakeInt
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">vif</span><span class="p">)</span><span class="c1">//3.3
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>变量，<code>Interface{}</code>，<code>Reflect.Value</code> 之间的关系如下</p>
<p><img src="https://i.loli.net/2020/03/23/7Je4mAnWbZx5wfE.png" alt="未命名绘图 1.png"></p>
<p>从<code>Interface()</code>到<code>reflect.Value</code>的可逆过程，正是反射的精髓所在。</p>
<h4 id="反射包中的一些方法">反射包中的一些方法</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span>	<span class="nx">返回变量的的静态类型</span>
<span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">.</span><span class="nf">kind</span><span class="p">()</span>	<span class="nx">返回变量的基本类型</span>
<span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">.</span><span class="nf">Elem</span><span class="p">()</span>	<span class="nx">返回指针所指向的变量</span><span class="err">，</span><span class="nx">相当于</span><span class="s">`*`</span><span class="nx">操作</span>
<span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">.</span><span class="nf">canSet</span><span class="p">()</span>	<span class="nx">返回变量是否可以被修改</span>
<span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">.</span><span class="nf">SetT</span><span class="p">()</span>	<span class="nx">设置变量的值</span><span class="err">，</span><span class="nx">T指变量类型</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="结构体的反射操作">结构体的反射操作</h4>
<h2 id="go-route">go route</h2>
<h2 id="channel">channel</h2>
<ul>
<li></li>
</ul>
<h2 id="异常处理">异常处理</h2>
<p>panic</p>
<ul>
<li></li>
</ul>
<h2 id="time">time</h2>
<ul>
<li></li>
</ul>
<h2 id="闭包">闭包</h2>
]]></description>
                
                
                
                
                
                    
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://1aomn.com/tags/go/">Go</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>搭建Hugo博客，通过Netlify自动部署</title>
                <link>https://1aomn.com/skills/build-a-blog/</link>
                <guid isPermaLink="true">https://1aomn.com/skills/build-a-blog/</guid>
                <pubDate>Fri, 06 Mar 2020 22:02:46 +0800</pubDate>
                
                    <author>burningdian@gmail.com (秋屿)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description><![CDATA[<blockquote>
<p>本文章基于Windows10，Hugo_extended_0.66.0，博客发布的流程是本地上传到github，触发hook后，netlify自动发布</p>
</blockquote>
<h2 id="一下载并安装hugo">一、下载并安装Hugo</h2>
<ul>
<li>
<p><a href="https://github.com/gohugoio/hugo/releases">Hugo下载地址</a></p>
<p>本教程选择了<img src="https://i.loli.net/2020/03/07/zT8oSZCOAib1q4J.png" alt="1583507935042.png">安装，该版本增加了对sass的支持 。</p>
<h4 id="第1步安装hugo">第1步：安装Hugo</h4>
<p>下载解压，完成之后，把hugo.exe添加到全局变量<code>Path</code>。<img src="https://i.loli.net/2020/03/07/LPQvA3RNwEGMJhm.png" alt="1583508112162.png">在控制台中验证安装成功。</p>
</li>
<li>
<p>在Github上新建仓库hugo-on-netlify，并在D:\Blog目录下打开Gitbash，输入指令。</p>
<blockquote>
<p>$ git clone  <a href="https://github.com/xxxxx/hugo-on-netlify">https://github.com/xxxxx/hugo-on-netlify</a></p>
<p>$ hugo new site hugo-on-netlify --force</p>
</blockquote>
<p>此时便会在hugo-on-netlify文件夹里生成网站需要的文件，文件结构如下。</p>
<blockquote>
<pre><code>myblog
├── archetypes
│   └── default.md
├── content
├── data
├── layouts
├── static
├── themes
└── config.toml
</code></pre></blockquote>
</li>
</ul>
<h4 id="第2步安装主题meme">第2步：安装主题Meme</h4>
<p>Hugo是没有默认主题的，这里选用主题<a href="https://github.com/reuixiy/hugo-theme-meme">Meme</a>。</p>
<blockquote>
<p>$ git clone  <a href="https://github.com/reuixiy/hugo-theme-meme.git">https://github.com/reuixiy/hugo-theme-meme.git</a> themes/meme</p>
</blockquote>
<p>然后替换 <code>config.toml</code> 为 <a href="https://github.com/reuixiy/hugo-theme-meme/blob/master/config-examples/zh-cn/config.toml">config.toml</a> ，可以在其中进行个性化设置。</p>
<h4 id="第3步测试">第3步：测试</h4>
<p>创建测试页面</p>
<blockquote>
<p>$ hugo new posts/my-first-post.md</p>
<p>$ hugo new about/_index.md</p>
</blockquote>
<p>此时，基本工作已经完成了，使用</p>
<blockquote>
<p>$ hugo server -D</p>
</blockquote>
<p>在浏览器里访问<code>http://localhost:1313/</code>，预览博客效果。</p>
<h2 id="二上传github">二、上传Github</h2>
<p>之前我们已经新建了hugo-on-netlify仓库，下一步把博客上传</p>
<blockquote>
<p>$ git add .  #将所有文件添加到仓库里</p>
<p>$ git commit -m &quot;commit message&quot;</p>
<p>$ git push -u origin master</p>
</blockquote>
<p>以上也是更新文章所需的操作，如果嫌麻烦，可以写一个bat脚本减轻工作量。</p>
<h2 id="三使用netlify发布网站">三、使用Netlify发布网站</h2>
<p>官网<a href="https://www.netlify.com/">Netlify</a>可以直接通过Github登录，非常方便。</p>
<h4 id="第1步配置文件">第1步：配置文件</h4>
<p>首先在网站根目录下添加<code>netlify.toml</code>文件，如官网所示：</p>
<blockquote>
<p>[build]
publish = &quot;public&quot;
command = &quot;hugo --gc --minify&quot;</p>
<p>[context.production.environment]
HUGO_VERSION = &quot;0.66.0&quot;
HUGO_ENV = &quot;production&quot;
HUGO_ENABLEGITINFO = &quot;true&quot;</p>
<p>[context.split1]
command = &quot;hugo --gc --minify --enableGitInfo&quot;</p>
<p>[context.split1.environment]
HUGO_VERSION = &quot;0.66.0&quot;
HUGO_ENV = &quot;production&quot;</p>
<p>[context.deploy-preview]
command = &quot;hugo --gc --minify --buildFuture -b $DEPLOY_PRIME_URL&quot;</p>
<p>[context.deploy-preview.environment]
HUGO_VERSION = &quot;0.66.0&quot;</p>
<p>[context.branch-deploy]
command = &quot;hugo --gc --minify -b $DEPLOY_PRIME_URL&quot;</p>
<p>[context.branch-deploy.environment]
HUGO_VERSION = &quot;0.66.0&quot;</p>
<p>[context.next.environment]
HUGO_ENABLEGITINFO = &quot;true&quot;</p>
</blockquote>
<h4 id="第2步netlify配置">第2步：Netlify配置</h4>
<p>根据官网的指引，连接Github中的blog-on-netlify仓库，然后修改设置。</p>
<p>首先修改<code>Build settings</code>，因为需要Netlify通过hugo构建，故做如下修改</p>
<p><img src="https://i.loli.net/2020/03/07/Cms9vcMBQaoZxfO.png" alt="1583510667070.png"></p>
<p>然后修改</p>
<p><img src="https://i.loli.net/2020/03/07/nEK6tA4o2NzQyGq.png" alt="1583510849748.png"></p>
<p>这里的修改是因为Netlify默认使用的Hugo版本过低，需要手动设置，否则不支持Meme主题。</p>
<h4 id="第3步完成">第3步：完成</h4>
<p>构建完成后，Netlify会自动生成一个二级域名，指向你的博客，至此Hugo博客的搭建就完成了。</p>
<h2 id="四自定义域名">四、自定义域名</h2>
<p>因为之前在腾讯云上搭建过博客，也是在上面注册的.com域名，所以这里以腾讯云的DNS解析操作为例。</p>
<p>操作很简单，首先在Domian management中添加域名<img src="https://i.loli.net/2020/03/07/QN67BfgvWCZuHFE.png" alt="1583511456178.png">然后在腾讯云域名的解析记录里添加两条记录。</p>
<p><img src="https://i.loli.net/2020/03/09/xan3kQCeifIWtvy.png" alt="image.png"></p>
<p>等待10分钟后，就可以通过域名访问自己的网站了。</p>
<p>Netlify推荐使用 SSL/TLS 的域名，白嫖的方法很多，这里就不赘述了。</p>
]]></description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
    </channel>
</rss>
